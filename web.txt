==============
File: src/integrations/supabase/categories.ts
================
import { supabase } from "@/integrations/supabase/client";
import { cache } from "react";

const sb = supabase as any;

export interface Category {
  id: string;
  name: string;
  icon_url?: string | null;
  products_count?: number;
}

export interface CategoryLight {
  id: string;
  name: string;
  icon_url?: string | null;
}

export interface CategoryInput {
  name: string;
  icon_url?: string | null;
}

export interface CategoryQueryOptions {
  search?: string;
  page?: number;
  limit?: number;
}

export const fetchCategories = cache(async ({ search = '', page = 1, limit = 10 }: CategoryQueryOptions) => {
  let query = sb
    .from('categories')
    .select('*, products(count)', { count: 'exact' });

  if (search.trim()) {
    query = query.ilike('name', `%${search.trim()}%`);
  }

  const from = (page - 1) * limit;
  const to = from + limit - 1;

  query = query.range(from, to).order('created_at', { ascending: false });

  const { data, error, count } = await query;

  if (error) throw error;

  const formattedData = data.map((cat: any) => ({
    ...cat,
    products_count: cat.products[0]?.count || 0,
  }));

  return { data: formattedData as Category[], count: count ?? 0 };
});

export const fetchCategoriesLight = cache(async (): Promise<CategoryLight[]> => {
  const { data, error } = await sb
    .from('categories')
    .select('id, name, icon_url')
    .order('created_at', { ascending: false })
    .limit(20);

  if (error) throw error;

  return data as CategoryLight[];
});

export async function createCategory(categoryData: CategoryInput): Promise<Category> {
  const { data, error } = await sb
    .from('categories')
    .insert(categoryData)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

export async function updateCategory(id: string, updates: Partial<CategoryInput>): Promise<Category> {
  const { data, error } = await sb
    .from('categories')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteCategory(id: string): Promise<void> {
  const { error } = await sb
    .from('categories')
    .delete()
    .eq('id', id);

  if (error) throw error;
}

================
File: src/integrations/supabase/client.ts
================
import { createBrowserClient } from "@supabase/ssr";
import type { Database } from "./types";

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

// Narrow types at runtime: ensure env vars exist so we can pass `string` to the client.
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
   // Throwing here makes the missing-config obvious at startup instead of a runtime type mismatch.
   throw new Error(
      "Missing required Supabase environment variables: NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY"
   );
}

// Only use localStorage in the browser
const isBrowser = typeof window !== "undefined";

export const supabase = createBrowserClient<Database>(
   SUPABASE_URL,
   SUPABASE_PUBLISHABLE_KEY,
   {
      auth: {
         storage: isBrowser ? localStorage : undefined,
         persistSession: isBrowser,
         autoRefreshToken: isBrowser,
      },
   }
);

================
File: src/integrations/supabase/external-orders.ts
================
import { supabase } from "@/integrations/supabase/client";
import { Order } from "@/types/orders";

const sb = supabase as any;

export interface ExternalOrderItemInput {
   product_name: string;
   quantity: number;
   price: number;
   product_id?: string;
   variation_name?: string;
}

export interface ExternalOrderInput {
   customer_name: string;
   customer_email?: string;
   customer_phone: string;
   delivery_address: string;
   delivery_city: string;
   delivery_notes?: string;
   status: "pending" | "processing" | "shipped" | "delivered" | "cancelled";
   source: "whatsapp" | "phone" | "other";
   total: number;
   items: ExternalOrderItemInput[];
   is_external: boolean;
   is_paid: boolean;
}

export async function createExternalOrder(
   data: ExternalOrderInput
): Promise<Order> {
   const {
      customer_name,
      customer_email,
      customer_phone,
      delivery_address,
      delivery_city,
      delivery_notes,
      status,
      source,
      total,
      items,
      is_external,
      is_paid,
   } = data;
   // Validate input
   if (!customer_name || !customer_phone || !delivery_address) {
      throw new Error("Missing required fields");
   }

   if (!items || items.length === 0) {
      throw new Error("Order must have at least one item");
   }

   // Determine whether there's a logged-in user on the client.
   // If there is, attach their id to satisfy common RLS policies
   // that allow inserts when user_id = auth.uid.
   let userId: string | null = null;
   try {
      // supabase-js v2
      const userResult = await sb.auth.getUser();
      // userResult may contain { data: { user } }
      // defensively read the id
      // @ts-ignore
      userId = userResult?.data?.user?.id ?? null;
   } catch (err) {
      // ignore - we'll just insert with null user_id if no session
      userId = null;
   }

   // Create the order in the database
   const { data: orderData, error: orderError } = await sb
      .from("orders")
      .insert([
         {
            status,
            subtotal: total,
            total,
            currency: "RWF",
            user_id: userId, // attach user id when available to satisfy RLS
            customer_email: customer_email || "",
            customer_first_name: customer_name.split(" ")[0],
            customer_last_name: customer_name.split(" ").slice(1).join(" "),
            customer_phone,
            delivery_address,
            delivery_city,
            delivery_notes,
            source,
            is_external: true,
            is_paid: is_paid ?? true,
         },
      ])
      .select()
      .single();

   if (orderError) {
      console.error("Order creation error:", orderError);
      // Common cause: row-level security prevents anonymous inserts. Provide a clearer message.
      if (orderError.code === "42501") {
         throw new Error(
            "Row-level security prevented inserting the order. Ensure you're authenticated or use a server endpoint with service role privileges."
         );
      }
      throw new Error(`Failed to create order: ${orderError.message}`);
   }

   // Create order items
   const orderItems = items.map((item: ExternalOrderItemInput) => ({
      order_id: orderData.id,
      product_id: item.product_id,
      product_name: item.product_name,
      variation_name: item.variation_name,
      price: item.price,
      quantity: item.quantity,
      total: item.price * item.quantity,
   }));

   const { error: itemsError } = await sb
      .from("order_items")
      .insert(orderItems);

   if (itemsError) {
      // Try to rollback the order
      await sb.from("orders").delete().eq("id", orderData.id);
      console.error("Order items creation error:", itemsError);
      throw new Error(`Failed to create order items: ${itemsError.message}`);
   }

   return orderData;
}

================
File: src/integrations/supabase/subcategories.ts
================
import { supabase } from "@/integrations/supabase/client";

const sb = supabase as any;

export interface Subcategory {
  id: string;
  name: string;
  category_id: string;
  created_at: string;
}

export interface SubcategoryInput {
  name: string;
  category_id: string;
}

export interface SubcategoryQueryOptions {
  category_id?: string;
  search?: string;
  page?: number;
  limit?: number;
}

export async function fetchSubcategories({ category_id, search = '', page = 1, limit = 10 }: SubcategoryQueryOptions) {
  let query = sb
    .from('subcategories')
    .select('*');

  if (category_id) {
    query = query.eq('category_id', category_id);
  }

  if (search.trim()) {
    query = query.ilike('name', `%${search.trim()}%`);
  }

  const from = (page - 1) * limit;
  const to = from + limit - 1;

  query = query.range(from, to).order('created_at', { ascending: false });

  const { data, error, count } = await query;

  if (error) throw error;

  return { data: data as Subcategory[], count: count ?? 0 };
}

export async function createSubcategory(subcategoryData: SubcategoryInput): Promise<Subcategory> {
  const { data, error } = await sb
    .from('subcategories')
    .insert(subcategoryData)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateSubcategory(id: string, updates: Partial<SubcategoryInput>): Promise<Subcategory> {
  const { data, error } = await sb
    .from('subcategories')
    .update(updates)
    .eq('id', id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteSubcategory(id: string): Promise<void> {
  const { error } = await sb
    .from('subcategories')
    .delete()
    .eq('id', id);

  if (error) throw error;
}

================
File: src/integrations/supabase/transactions-server.ts
================
import { createClient } from '@/utils/supabase/server';
import { Transaction, TransactionQueryOptions, TransactionStats } from './transactions';
import type { SupabaseClient } from '@supabase/supabase-js';

// Server-side functions for API routes
export async function fetchAllTransactionsServer(
  options: TransactionQueryOptions = {}, 
  serviceClient?: SupabaseClient
) {
  const supabase = serviceClient || await createClient();
  
  const {
    page = 1,
    limit = 20,
    status,
    payment_method,
    search,
    sortBy = 'created_at',
    sortOrder = 'desc',
    startDate,
    endDate
  } = options;

  let query = supabase
    .from('payments')
    .select(`
      *,
      order:orders (
        id,
        order_number,
        status,
        customer_first_name,
        customer_last_name,
        customer_email,
        customer_phone,
        total,
        payment_status,
        delivery_address,
        delivery_city,
        delivery_notes,
        user_id,
        created_at,
        updated_at,
        items:order_items (
          id,
          product_name,
          product_sku,
          variation_name,
          price,
          quantity,
          total
        )
      )
    `, { count: 'exact' });

  // Apply filters
  if (status && status !== 'all') {
    query = query.eq('status', status);
  }

  if (payment_method && payment_method !== 'all') {
    query = query.eq('payment_method', payment_method);
  }

  if (search) {
    query = query.or(
      `customer_name.ilike.%${search}%,customer_email.ilike.%${search}%,reference.ilike.%${search}%,kpay_transaction_id.ilike.%${search}%`
    );
  }

  if (startDate) {
    query = query.gte('created_at', startDate);
  }

  if (endDate) {
    query = query.lte('created_at', endDate);
  }

  // Apply sorting
  query = query.order(sortBy, { ascending: sortOrder === 'asc' });

  // Apply pagination
  const start = (page - 1) * limit;
  query = query.range(start, start + limit - 1);

  const { data, error, count } = await query;

  if (error) {
    console.error('Error fetching transactions server:', error);
    throw new Error(error.message);
  }

  return {
    transactions: data || [],
    pagination: {
      page,
      limit,
      total: count || 0,
      pages: Math.ceil((count || 0) / limit),
    },
  };
}

export async function getTransactionCountsByStatusServer(serviceClient?: SupabaseClient) {
  const supabase = serviceClient || await createClient();
  
  const { data, error } = await supabase
    .from('payments')
    .select('status')
    .order('status');
  
  if (error) {
    console.error('Error fetching transaction counts:', error);
    throw new Error(error.message);
  }
  
  // Count transactions by status
  const counts = data.reduce((acc: any, payment: any) => {
    const status = payment.status;
    acc[status] = (acc[status] || 0) + 1;
    acc.total = (acc.total || 0) + 1;
    return acc;
  }, {});
  
  return {
    all: counts.total || 0,
    pending: counts.pending || 0,
    completed: counts.completed || 0,
    failed: counts.failed || 0,
    timeout: counts.timeout || 0,
  };
}

export async function getTransactionStatsServer(serviceClient?: SupabaseClient): Promise<TransactionStats> {
  const supabase = serviceClient || await createClient();
  
  // Get current period stats (last 7 days)
  const currentDate = new Date();
  const currentWeekStart = new Date(currentDate.getTime() - 7 * 24 * 60 * 60 * 1000);
  const previousWeekStart = new Date(currentWeekStart.getTime() - 7 * 24 * 60 * 60 * 1000);

  // Current week stats
  const { data: currentStats } = await supabase
    .from('payments')
    .select('status, amount')
    .gte('created_at', currentWeekStart.toISOString());

  // Previous week stats for comparison
  const { data: previousStats } = await supabase
    .from('payments')
    .select('status, amount')
    .gte('created_at', previousWeekStart.toISOString())
    .lt('created_at', currentWeekStart.toISOString());

  // Calculate current stats
  let totalRevenue = 0;
  let completedTransactions = 0;
  let failedTransactions = 0;
  let pendingTransactions = 0;

  currentStats?.forEach((payment: { status: string; amount: number }) => {
    if (payment.status === 'completed') {
      totalRevenue += payment.amount;
      completedTransactions += 1;
    } else if (payment.status === 'failed') {
      failedTransactions += 1;
    } else if (payment.status === 'pending') {
      pendingTransactions += 1;
    }
  });

  // Calculate previous stats for change calculation
  let previousRevenue = 0;
  let previousCompleted = 0;
  let previousFailed = 0;
  let previousPending = 0;

  previousStats?.forEach((payment: { status: string; amount: number }) => {
    if (payment.status === 'completed') {
      previousRevenue += payment.amount;
      previousCompleted += 1;
    } else if (payment.status === 'failed') {
      previousFailed += 1;
    } else if (payment.status === 'pending') {
      previousPending += 1;
    }
  });

  // Calculate percentage changes
  const calculateChange = (current: number, previous: number) => {
    if (previous === 0) return current > 0 ? 100 : 0;
    return ((current - previous) / previous) * 100;
  };

  return {
    totalRevenue,
    completedTransactions,
    failedTransactions,
    pendingTransactions,
    revenueChange: calculateChange(totalRevenue, previousRevenue),
    completedChange: calculateChange(completedTransactions, previousCompleted),
    failedChange: calculateChange(failedTransactions, previousFailed),
    pendingChange: calculateChange(pendingTransactions, previousPending),
  };
}

export async function fetchTransactionByIdServer(id: string, serviceClient?: SupabaseClient): Promise<Transaction> {
  const supabase = serviceClient || await createClient();
  
  const { data, error } = await supabase
    .from('payments')
    .select(`
      *,
      order:orders!inner (
        id,
        order_number,
        status,
        customer_first_name,
        customer_last_name,
        customer_email,
        customer_phone,
        total,
        payment_status,
        delivery_address,
        delivery_city,
        delivery_notes,
        user_id,
        created_at,
        updated_at,
        items:order_items (
          id,
          product_name,
          product_sku,
          variation_name,
          price,
          quantity,
          total
        )
      )
    `)
    .eq('id', id)
    .single();

  if (error) {
    console.error('Error fetching transaction:', error);
    throw new Error(error.message);
  }

  return data;
}

================
File: src/integrations/supabase/transactions.ts
================
import { createClient } from '@/utils/supabase/client';

export interface Transaction {
  id: string;
  order_id: string;
  amount: number;
  currency: string;
  payment_method: string;
  status: 'pending' | 'completed' | 'failed' | 'timeout';
  reference: string;
  kpay_transaction_id?: string;
  customer_name: string;
  customer_email: string;
  customer_phone: string;
  created_at: string;
  updated_at: string;
  completed_at?: string;
  failure_reason?: string;
  client_timeout?: boolean;
  client_timeout_reason?: string;
  kpay_mom_transaction_id?: string;
  // Order details
  order?: {
    id: string;
    order_number?: string;
    status: string;
    customer_first_name: string;
    customer_last_name: string;
    customer_email: string;
    customer_phone: string;
    total: number;
    payment_status: string;
    delivery_address?: string;
    delivery_city?: string;
    delivery_notes?: string;
    user_id?: string;
    created_at: string;
    updated_at: string;
    items?: {
      id: string;
      product_name: string;
      product_sku?: string;
      variation_name?: string;
      price: number;
      quantity: number;
      total: number;
    }[];
  };
}

export interface TransactionQueryOptions {
  page?: number;
  limit?: number;
  status?: string;
  payment_method?: string;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  startDate?: string;
  endDate?: string;
}

export interface TransactionStats {
  totalRevenue: number;
  completedTransactions: number;
  failedTransactions: number;
  pendingTransactions: number;
  revenueChange: number;
  completedChange: number;
  failedChange: number;
  pendingChange: number;
}

// Fetch all transactions (admin only)
export async function fetchAllTransactions(options: TransactionQueryOptions = {}) {
  const supabase = createClient();
  
  const {
    page = 1,
    limit = 20,
    status,
    payment_method,
    search,
    sortBy = 'created_at',
    sortOrder = 'desc',
    startDate,
    endDate
  } = options;

  let query = supabase
    .from('payments')
    .select(`
      *,
      order:orders!inner (
        id,
        order_number,
        status,
        customer_first_name,
        customer_last_name,
        customer_email,
        customer_phone,
        total,
        payment_status,
        delivery_address,
        delivery_city,
        delivery_notes,
        user_id,
        created_at,
        updated_at,
        items:order_items (
          id,
          product_name,
          product_sku,
          variation_name,
          price,
          quantity,
          total
        )
      )
    `);

  // Apply filters
  if (status && status !== 'all') {
    query = query.eq('status', status);
  }

  if (payment_method && payment_method !== 'all') {
    query = query.eq('payment_method', payment_method);
  }

  if (search) {
    query = query.or(
      `customer_name.ilike.%${search}%,customer_email.ilike.%${search}%,reference.ilike.%${search}%,kpay_transaction_id.ilike.%${search}%`
    );
  }

  if (startDate) {
    query = query.gte('created_at', startDate);
  }

  if (endDate) {
    query = query.lte('created_at', endDate);
  }

  // Apply sorting
  query = query.order(sortBy, { ascending: sortOrder === 'asc' });

  // Apply pagination
  const start = (page - 1) * limit;
  query = query.range(start, start + limit - 1);

  const { data, error, count } = await query;

  if (error) {
    console.error('Error fetching transactions:', error);
    throw new Error(error.message);
  }

  return {
    transactions: data || [],
    pagination: {
      page,
      limit,
      total: count || 0,
      pages: Math.ceil((count || 0) / limit),
    },
  };
}

// Fetch transaction statistics
export async function getTransactionStats(): Promise<TransactionStats> {
  const supabase = createClient();
  
  // Get current period stats (last 7 days)
  const currentDate = new Date();
  const currentWeekStart = new Date(currentDate.getTime() - 7 * 24 * 60 * 60 * 1000);
  const previousWeekStart = new Date(currentWeekStart.getTime() - 7 * 24 * 60 * 60 * 1000);

  // Current week stats
  const { data: currentStats } = await supabase
    .from('payments')
    .select('status, amount')
    .gte('created_at', currentWeekStart.toISOString());

  // Previous week stats for comparison
  const { data: previousStats } = await supabase
    .from('payments')
    .select('status, amount')
    .gte('created_at', previousWeekStart.toISOString())
    .lt('created_at', currentWeekStart.toISOString());

  // Calculate current stats
  let totalRevenue = 0;
  let completedTransactions = 0;
  let failedTransactions = 0;
  let pendingTransactions = 0;

  currentStats?.forEach((payment: { status: string; amount: number }) => {
    if (payment.status === 'completed') {
      totalRevenue += payment.amount;
      completedTransactions += 1;
    } else if (payment.status === 'failed') {
      failedTransactions += 1;
    } else if (payment.status === 'pending') {
      pendingTransactions += 1;
    }
  });

  // Calculate previous stats for change calculation
  let previousRevenue = 0;
  let previousCompleted = 0;
  let previousFailed = 0;
  let previousPending = 0;

  previousStats?.forEach((payment: { status: string; amount: number }) => {
    if (payment.status === 'completed') {
      previousRevenue += payment.amount;
      previousCompleted += 1;
    } else if (payment.status === 'failed') {
      previousFailed += 1;
    } else if (payment.status === 'pending') {
      previousPending += 1;
    }
  });

  // Calculate percentage changes
  const calculateChange = (current: number, previous: number) => {
    if (previous === 0) return current > 0 ? 100 : 0;
    return ((current - previous) / previous) * 100;
  };

  return {
    totalRevenue,
    completedTransactions,
    failedTransactions,
    pendingTransactions,
    revenueChange: calculateChange(totalRevenue, previousRevenue),
    completedChange: calculateChange(completedTransactions, previousCompleted),
    failedChange: calculateChange(failedTransactions, previousFailed),
    pendingChange: calculateChange(pendingTransactions, previousPending),
  };
}

// Fetch single transaction by ID
export async function fetchTransactionById(id: string) {
  const supabase = createClient();
  
  const { data, error } = await supabase
    .from('payments')
    .select(`
      *,
      order:orders!inner (
        id,
        order_number,
        status,
        customer_first_name,
        customer_last_name,
        customer_email,
        customer_phone,
        total,
        payment_status,
        delivery_address,
        delivery_city,
        delivery_notes,
        user_id,
        created_at,
        updated_at,
        items:order_items (
          id,
          product_name,
          product_sku,
          variation_name,
          price,
          quantity,
          total
        )
      )
    `)
    .eq('id', id)
    .single();

  if (error) {
    console.error('Error fetching transaction:', error);
    throw new Error(error.message);
  }

  return data;
}

================
File: src/integrations/supabase/types.ts
================
export type Json =
   | string
   | number
   | boolean
   | null
   | { [key: string]: Json | undefined }
   | Json[];

export type Database = {
   // Allows to automatically instantiate createClient with right options
   // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
   __InternalSupabase: {
      PostgrestVersion: "13.0.4";
   };
   public: {
      Tables: {
         categories: {
            Row: {
               created_at: string;
               icon_url: string | null;
               id: string;
               name: string;
            };
            Insert: {
               created_at?: string;
               icon_url?: string | null;
               id?: string;
               name: string;
            };
            Update: {
               created_at?: string;
               icon_url?: string | null;
               id?: string;
               name?: string;
            };
            Relationships: [];
         };
         product_images: {
            Row: {
               created_at: string;
               id: string;
               is_primary: boolean;
               position: number;
               product_id: string;
               url: string;
            };
            Insert: {
               created_at?: string;
               id?: string;
               is_primary?: boolean;
               position?: number;
               product_id: string;
               url: string;
            };
            Update: {
               created_at?: string;
               id?: string;
               is_primary?: boolean;
               position?: number;
               product_id?: string;
               url?: string;
            };
            Relationships: [
               {
                  foreignKeyName: "product_images_product_id_fkey";
                  columns: ["product_id"];
                  isOneToOne: false;
                  referencedRelation: "products";
                  referencedColumns: ["id"];
               }
            ];
         };
         product_variations: {
            Row: {
               attributes: Json;
               created_at: string;
               id: string;
               name: string | null;
               price: number | null;
               product_id: string;
               sku: string | null;
               stock: number;
               updated_at: string;
            };
            Insert: {
               attributes?: Json;
               created_at?: string;
               id?: string;
               name?: string | null;
               price?: number | null;
               product_id: string;
               sku?: string | null;
               stock?: number;
               updated_at?: string;
            };
            Update: {
               attributes?: Json;
               created_at?: string;
               id?: string;
               name?: string | null;
               price?: number | null;
               product_id?: string;
               sku?: string | null;
               stock?: number;
               updated_at?: string;
            };
            Relationships: [
               {
                  foreignKeyName: "product_variations_product_id_fkey";
                  columns: ["product_id"];
                  isOneToOne: false;
                  referencedRelation: "products";
                  referencedColumns: ["id"];
               }
            ];
         };
         products: {
            Row: {
               barcode: string | null;
               brand: string | null;
               category: string | null;
               category_id: string | null;
               compare_at_price: number | null;
               continue_selling_when_oos: boolean;
               cost_price: number | null;
               created_at: string;
               description: string | null;
               dimensions: string | null;
               featured: boolean;
               id: string;
               main_image_url: string | null;
               meta_description: string | null;
               meta_title: string | null;
               name: string;
               price: number;
               requires_shipping: boolean;
               short_description: string | null;
               sku: string | null;
               status: Database["public"]["Enums"]["app_product_status"];
               stock: number;
               subcategory: string | null;
               subcategory_id: string | null;
               tags: string[];
               taxable: boolean;
               track_quantity: boolean;
               updated_at: string;
               weight_kg: number | null;
            };
            Insert: {
               barcode?: string | null;
               brand?: string | null;
               category?: string | null;
               category_id?: string | null;
               compare_at_price?: number | null;
               continue_selling_when_oos?: boolean;
               cost_price?: number | null;
               created_at?: string;
               description?: string | null;
               dimensions?: string | null;
               featured?: boolean;
               id?: string;
               main_image_url?: string | null;
               meta_description?: string | null;
               meta_title?: string | null;
               name: string;
               price?: number;
               requires_shipping?: boolean;
               short_description?: string | null;
               sku?: string | null;
               status?: Database["public"]["Enums"]["app_product_status"];
               stock?: number;
               subcategory?: string | null;
               subcategory_id?: string | null;
               tags?: string[];
               taxable?: boolean;
               track_quantity?: boolean;
               updated_at?: string;
               weight_kg?: number | null;
            };
            Update: {
               barcode?: string | null;
               brand?: string | null;
               category?: string | null;
               category_id?: string | null;
               compare_at_price?: number | null;
               continue_selling_when_oos?: boolean;
               cost_price?: number | null;
               created_at?: string;
               description?: string | null;
               dimensions?: string | null;
               featured?: boolean;
               id?: string;
               main_image_url?: string | null;
               meta_description?: string | null;
               meta_title?: string | null;
               name?: string;
               price?: number;
               requires_shipping?: boolean;
               short_description?: string | null;
               sku?: string | null;
               status?: Database["public"]["Enums"]["app_product_status"];
               stock?: number;
               subcategory?: string | null;
               subcategory_id?: string | null;
               tags?: string[];
               taxable?: boolean;
               track_quantity?: boolean;
               updated_at?: string;
               weight_kg?: number | null;
            };
            Relationships: [
               {
                  foreignKeyName: "products_category_id_fkey";
                  columns: ["category_id"];
                  isOneToOne: false;
                  referencedRelation: "categories";
                  referencedColumns: ["id"];
               },
               {
                  foreignKeyName: "products_subcategory_id_fkey";
                  columns: ["subcategory_id"];
                  isOneToOne: false;
                  referencedRelation: "subcategories";
                  referencedColumns: ["id"];
               }
            ];
         };
         profiles: {
            Row: {
               address: string | null;
               avatar_url: string | null;
               city: string | null;
               created_at: string;
               full_name: string | null;
               id: string;
               phone: string | null;
               updated_at: string;
            };
            Insert: {
               address?: string | null;
               avatar_url?: string | null;
               city?: string | null;
               created_at?: string;
               full_name?: string | null;
               id: string;
               phone?: string | null;
               updated_at?: string;
            };
            Update: {
               address?: string | null;
               avatar_url?: string | null;
               city?: string | null;
               created_at?: string;
               full_name?: string | null;
               id?: string;
               phone?: string | null;
               updated_at?: string;
            };
            Relationships: [];
         };
         subcategories: {
            Row: {
               category_id: string;
               created_at: string;
               id: string;
               name: string;
            };
            Insert: {
               category_id: string;
               created_at?: string;
               id?: string;
               name: string;
            };
            Update: {
               category_id?: string;
               created_at?: string;
               id?: string;
               name?: string;
            };
            Relationships: [
               {
                  foreignKeyName: "subcategories_category_id_fkey";
                  columns: ["category_id"];
                  isOneToOne: false;
                  referencedRelation: "categories";
                  referencedColumns: ["id"];
               }
            ];
         };
         user_roles: {
            Row: {
               created_at: string;
               id: string;
               role: Database["public"]["Enums"]["app_role"];
               user_id: string;
            };
            Insert: {
               created_at?: string;
               id?: string;
               role: Database["public"]["Enums"]["app_role"];
               user_id: string;
            };
            Update: {
               created_at?: string;
               id?: string;
               role?: Database["public"]["Enums"]["app_role"];
               user_id?: string;
            };
            Relationships: [];
         };
         wishlist: {
            Row: {
               created_at: string;
               id: string;
               product_id: string;
               user_id: string;
            };
            Insert: {
               created_at?: string;
               id?: string;
               product_id: string;
               user_id: string;
            };
            Update: {
               created_at?: string;
               id?: string;
               product_id?: string;
               user_id?: string;
            };
            Relationships: [
               {
                  foreignKeyName: "wishlist_product_id_fkey";
                  columns: ["product_id"];
                  isOneToOne: false;
                  referencedRelation: "products";
                  referencedColumns: ["id"];
               },
               {
                  foreignKeyName: "wishlist_user_id_fkey";
                  columns: ["user_id"];
                  isOneToOne: false;
                  referencedRelation: "users";
                  referencedColumns: ["id"];
               }
            ];
         };
      };
      Views: {
         [_ in never]: never;
      };
      Functions: {
         get_product_stats: {
            Args: Record<PropertyKey, never>;
            Returns: Json;
         };
         has_role: {
            Args: {
               _role: Database["public"]["Enums"]["app_role"];
               _user_id: string;
            };
            Returns: boolean;
         };
      };
      Enums: {
         app_product_status: "active" | "draft" | "out_of_stock";
         app_role: "admin" | "user" | "rider";
         product_status: "draft" | "active" | "archived";
      };
      CompositeTypes: {
         [_ in never]: never;
      };
   };
};

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">;

type DefaultSchema = DatabaseWithoutInternals[Extract<
   keyof Database,
   "public"
>];

export type Tables<
   DefaultSchemaTableNameOrOptions extends
      | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
      | { schema: keyof DatabaseWithoutInternals },
   TableName extends DefaultSchemaTableNameOrOptions extends {
      schema: keyof DatabaseWithoutInternals;
   }
      ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
           DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
      : never = never
> = DefaultSchemaTableNameOrOptions extends {
   schema: keyof DatabaseWithoutInternals;
}
   ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
        Row: infer R;
     }
      ? R
      : never
   : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
   ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
     }
      ? R
      : never
   : never;

export type TablesInsert<
   DefaultSchemaTableNameOrOptions extends
      | keyof DefaultSchema["Tables"]
      | { schema: keyof DatabaseWithoutInternals },
   TableName extends DefaultSchemaTableNameOrOptions extends {
      schema: keyof DatabaseWithoutInternals;
   }
      ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
      : never = never
> = DefaultSchemaTableNameOrOptions extends {
   schema: keyof DatabaseWithoutInternals;
}
   ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
        Insert: infer I;
     }
      ? I
      : never
   : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
   ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
     }
      ? I
      : never
   : never;

export type TablesUpdate<
   DefaultSchemaTableNameOrOptions extends
      | keyof DefaultSchema["Tables"]
      | { schema: keyof DatabaseWithoutInternals },
   TableName extends DefaultSchemaTableNameOrOptions extends {
      schema: keyof DatabaseWithoutInternals;
   }
      ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
      : never = never
> = DefaultSchemaTableNameOrOptions extends {
   schema: keyof DatabaseWithoutInternals;
}
   ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
        Update: infer U;
     }
      ? U
      : never
   : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
   ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
     }
      ? U
      : never
   : never;

export type Enums<
   DefaultSchemaEnumNameOrOptions extends
      | keyof DefaultSchema["Enums"]
      | { schema: keyof DatabaseWithoutInternals },
   EnumName extends DefaultSchemaEnumNameOrOptions extends {
      schema: keyof DatabaseWithoutInternals;
   }
      ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
      : never = never
> = DefaultSchemaEnumNameOrOptions extends {
   schema: keyof DatabaseWithoutInternals;
}
   ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
   : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
   ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
   : never;

export type CompositeTypes<
   PublicCompositeTypeNameOrOptions extends
      | keyof DefaultSchema["CompositeTypes"]
      | { schema: keyof DatabaseWithoutInternals },
   CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
      schema: keyof DatabaseWithoutInternals;
   }
      ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
      : never = never
> = PublicCompositeTypeNameOrOptions extends {
   schema: keyof DatabaseWithoutInternals;
}
   ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
   : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
   ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
   : never;

export const Constants = {
   public: {
      Enums: {
         app_product_status: ["active", "draft", "out_of_stock"],
         app_role: ["admin", "user", "rider"],
         product_status: ["draft", "active", "archived"],
      },
   },
} as const;

================
File: src/integrations/supabase/wishlist.ts
================
import { supabase } from "@/integrations/supabase/client";
import type { Product } from "@/integrations/supabase/products";

const sb = supabase as any;

export interface WishlistItem {
  id: string;
  user_id: string;
  product_id: string;
  created_at: string;
  product?: Product;
}

export interface WishlistItemWithProduct extends WishlistItem {
  product: Product;
}

// Add product to wishlist
export async function addToWishlist(productId: string): Promise<WishlistItem> {
  const { data: { user } } = await sb.auth.getUser();
  if (!user) throw new Error("User not authenticated");

  const { data, error } = await sb
    .from("wishlist")
    .insert({ product_id: productId, user_id: user.id })
    .select()
    .single();

  if (error) throw error;
  return data;
}

// Remove product from wishlist
export async function removeFromWishlist(productId: string): Promise<void> {
  const { error } = await sb
    .from("wishlist")
    .delete()
    .eq("product_id", productId);

  if (error) throw error;
}

// Check if product is in wishlist
export async function isInWishlist(productId: string): Promise<boolean> {
  const { data, error } = await sb
    .from("wishlist")
    .select("id")
    .eq("product_id", productId)
    .single();

  if (error && error.code !== 'PGRST116') throw error; // PGRST116 is "not found"
  return !!data;
}

// Get user's wishlist with products
export async function getWishlist(): Promise<WishlistItemWithProduct[]> {
  const { data, error } = await sb
    .from("wishlist")
    .select(`
      id,
      user_id,
      product_id,
      created_at,
      product:products(*)
    `)
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data || [];
}

// Get wishlist item count for user
export async function getWishlistCount(): Promise<number> {
  const { count, error } = await sb
    .from("wishlist")
    .select("*", { count: "exact", head: true });

  if (error) throw error;
  return count || 0;
}

// Toggle product in wishlist (add if not exists, remove if exists)
export async function toggleWishlist(productId: string): Promise<{ added: boolean; item?: WishlistItem }> {
  const isInWishlistAlready = await isInWishlist(productId);

  if (isInWishlistAlready) {
    await removeFromWishlist(productId);
    return { added: false };
  } else {
    const item = await addToWishlist(productId);
    return { added: true, item };
  }
}

================
File: src/lib/data-table.ts
================
import type { Column } from "@tanstack/react-table";
import { dataTableConfig } from "@/config/data-table";
import type {
  ExtendedColumnFilter,
  FilterOperator,
  FilterVariant,
} from "@/types/data-table";

export function getCommonPinningStyles<TData>({
  column,
  withBorder = false,
}: {
  column: Column<TData>;
  withBorder?: boolean;
}): React.CSSProperties {
  const isPinned = column.getIsPinned();
  const isLastLeftPinnedColumn =
    isPinned === "left" && column.getIsLastColumn("left");
  const isFirstRightPinnedColumn =
    isPinned === "right" && column.getIsFirstColumn("right");

  return {
    boxShadow: withBorder
      ? isLastLeftPinnedColumn
        ? "-4px 0 4px -4px hsl(var(--border)) inset"
        : isFirstRightPinnedColumn
          ? "4px 0 4px -4px hsl(var(--border)) inset"
          : undefined
      : undefined,
    left: isPinned === "left" ? `${column.getStart("left")}px` : undefined,
    right: isPinned === "right" ? `${column.getAfter("right")}px` : undefined,
    opacity: isPinned ? 0.97 : 1,
    position: isPinned ? "sticky" : "relative",
    background: isPinned ? "hsl(var(--background))" : "hsl(var(--background))",
    width: column.getSize(),
    zIndex: isPinned ? 1 : 0,
  };
}

export function getFilterOperators(filterVariant: FilterVariant) {
  const operatorMap: Record<
    FilterVariant,
    { label: string; value: FilterOperator }[]
  > = {
    text: dataTableConfig.textOperators,
    number: dataTableConfig.numericOperators,
    range: dataTableConfig.numericOperators,
    date: dataTableConfig.dateOperators,
    dateRange: dataTableConfig.dateOperators,
    boolean: dataTableConfig.booleanOperators,
    select: dataTableConfig.selectOperators,
    multiSelect: dataTableConfig.multiSelectOperators,
  };

  return operatorMap[filterVariant] ?? dataTableConfig.textOperators;
}

export function getDefaultFilterOperator(filterVariant: FilterVariant) {
  const operators = getFilterOperators(filterVariant);

  return operators[0]?.value ?? (filterVariant === "text" ? "iLike" : "eq");
}

export function getValidFilters<TData>(
  filters: ExtendedColumnFilter<TData>[],
): ExtendedColumnFilter<TData>[] {
  return filters.filter(
    (filter) =>
      filter.operator === "isEmpty" ||
      filter.operator === "isNotEmpty" ||
      (Array.isArray(filter.value)
        ? filter.value.length > 0
        : filter.value !== "" &&
          filter.value !== null &&
          filter.value !== undefined),
  );
}

================
File: src/lib/format.ts
================
export function formatDate(
  date: Date | string | number | undefined,
  opts: Intl.DateTimeFormatOptions = {},
) {
  if (!date) return "";

  try {
    return new Intl.DateTimeFormat("en-US", {
      month: opts.month ?? "long",
      day: opts.day ?? "numeric",
      year: opts.year ?? "numeric",
      ...opts,
    }).format(new Date(date));
  } catch (_err) {
    return "";
  }
}

================
File: src/lib/logger.ts
================
/**
 * Logger utility for the application
 * Provides structured logging with different levels and categories
 */

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';
export type LogCategory = 'payment' | 'webhook' | 'api' | 'user' | 'system';

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  category: LogCategory;
  message: string;
  data?: any;
  userId?: string;
  sessionId?: string;
  traceId?: string;
}

class Logger {
  private isDevelopment = process.env.NODE_ENV === 'development';
  
  private formatLog(entry: LogEntry): string {
    const { timestamp, level, category, message, data, userId, sessionId, traceId } = entry;
    
    let logString = `[${timestamp}] [${level.toUpperCase()}] [${category}] ${message}`;
    
    if (userId) logString += ` userId=${userId}`;
    if (sessionId) logString += ` sessionId=${sessionId}`;
    if (traceId) logString += ` traceId=${traceId}`;
    
    if (data) {
      logString += `\nData: ${JSON.stringify(data, null, 2)}`;
    }
    
    return logString;
  }

  private log(level: LogLevel, category: LogCategory, message: string, data?: any, context?: {
    userId?: string;
    sessionId?: string;
    traceId?: string;
  }) {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      category,
      message,
      data,
      ...context
    };

    const logString = this.formatLog(entry);

    // Always log errors and warnings
    if (level === 'error') {
      console.error(logString);
      
      // In production, you might want to send critical errors to an external service
      if (!this.isDevelopment) {
        // TODO: Send to external logging service (e.g., Sentry, LogRocket, etc.)
        // this.sendToExternalService(entry);
      }
    } else if (level === 'warn') {
      console.warn(logString);
    } else if (this.isDevelopment || level === 'info') {
      // In development, log everything. In production, only log info and above
      console.log(logString);
    }
  }

  // Payment-specific logging methods
  paymentInitiated(data: {
    orderId: string;
    amount: number;
    paymentMethod: string;
    userId?: string;
    transactionId?: string;
  }) {
    this.log('info', 'payment', 'Payment initiated', data, {
      userId: data.userId,
      traceId: `payment_${data.orderId}_${Date.now()}`
    });
  }

  paymentCompleted(data: {
    orderId: string;
    transactionId: string;
    amount: number;
    userId?: string;
  }) {
    this.log('info', 'payment', 'Payment completed successfully', data, {
      userId: data.userId,
      traceId: `payment_${data.orderId}_${Date.now()}`
    });
  }

  paymentFailed(data: {
    orderId: string;
    transactionId?: string;
    error: string;
    userId?: string;
  }) {
    this.log('error', 'payment', 'Payment failed', data, {
      userId: data.userId,
      traceId: `payment_${data.orderId}_${Date.now()}`
    });
  }

  webhookReceived(data: {
    transactionId: string;
    status: string;
    reference: string;
  }) {
    this.log('info', 'webhook', 'KPay webhook received', data, {
      traceId: `webhook_${data.transactionId}_${Date.now()}`
    });
  }

  webhookProcessed(data: {
    transactionId: string;
    status: string;
    success: boolean;
  }) {
    this.log('info', 'webhook', 'KPay webhook processed', data, {
      traceId: `webhook_${data.transactionId}_${Date.now()}`
    });
  }

  webhookError(error: string, data?: any) {
    this.log('error', 'webhook', 'KPay webhook processing error', { error, ...data }, {
      traceId: `webhook_error_${Date.now()}`
    });
  }

  apiError(endpoint: string, error: string, data?: any) {
    this.log('error', 'api', `API error at ${endpoint}`, { error, ...data }, {
      traceId: `api_error_${Date.now()}`
    });
  }

  userAction(action: string, data?: any, userId?: string) {
    this.log('info', 'user', `User action: ${action}`, data, {
      userId,
      traceId: `user_${userId}_${Date.now()}`
    });
  }

  systemError(error: string, data?: any) {
    this.log('error', 'system', 'System error', { error, ...data }, {
      traceId: `system_error_${Date.now()}`
    });
  }

  debug(category: LogCategory, message: string, data?: any) {
    if (this.isDevelopment) {
      this.log('debug', category, message, data);
    }
  }

  info(category: LogCategory, message: string, data?: any) {
    this.log('info', category, message, data);
  }

  warn(category: LogCategory, message: string, data?: any) {
    this.log('warn', category, message, data);
  }

  error(category: LogCategory, message: string, data?: any) {
    this.log('error', category, message, data);
  }
}

// Export singleton instance
export const logger = new Logger();

// Export utility functions for common use cases
export const logPaymentEvent = (event: string, data: any, userId?: string) => {
  logger.info('payment', event, { ...data, userId });
};

export const logError = (category: LogCategory, error: Error | string, data?: any) => {
  const errorMessage = error instanceof Error ? error.message : error;
  const errorStack = error instanceof Error ? error.stack : undefined;
  
  logger.error(category, errorMessage, {
    ...data,
    stack: errorStack
  });
};

export default logger;

================
File: src/lib/parsers.ts
================
import { createParser } from "nuqs/server";
import { z } from "zod";

import { dataTableConfig } from "@/config/data-table";

import type {
  ExtendedColumnFilter,
  ExtendedColumnSort,
} from "@/types/data-table";

const sortingItemSchema = z.object({
  id: z.string(),
  desc: z.boolean(),
});

export const getSortingStateParser = <TData>(
  columnIds?: string[] | Set<string>,
) => {
  const validKeys = columnIds
    ? columnIds instanceof Set
      ? columnIds
      : new Set(columnIds)
    : null;

  return createParser({
    parse: (value) => {
      try {
        const parsed = JSON.parse(value);
        const result = z.array(sortingItemSchema).safeParse(parsed);

        if (!result.success) return null;

        if (validKeys && result.data.some((item) => !validKeys.has(item.id))) {
          return null;
        }

        return result.data as ExtendedColumnSort<TData>[];
      } catch {
        return null;
      }
    },
    serialize: (value) => JSON.stringify(value),
    eq: (a, b) =>
      a.length === b.length &&
      a.every(
        (item, index) =>
          item.id === b[index]?.id && item.desc === b[index]?.desc,
      ),
  });
};

const filterItemSchema = z.object({
  id: z.string(),
  value: z.union([z.string(), z.array(z.string())]),
  variant: z.enum(dataTableConfig.filterVariants),
  operator: z.enum(dataTableConfig.operators),
  filterId: z.string(),
});

export type FilterItemSchema = z.infer<typeof filterItemSchema>;

export const getFiltersStateParser = <TData>(
  columnIds?: string[] | Set<string>,
) => {
  const validKeys = columnIds
    ? columnIds instanceof Set
      ? columnIds
      : new Set(columnIds)
    : null;

  return createParser({
    parse: (value) => {
      try {
        const parsed = JSON.parse(value);
        const result = z.array(filterItemSchema).safeParse(parsed);

        if (!result.success) return null;

        if (validKeys && result.data.some((item) => !validKeys.has(item.id))) {
          return null;
        }

        return result.data as ExtendedColumnFilter<TData>[];
      } catch {
        return null;
      }
    },
    serialize: (value) => JSON.stringify(value),
    eq: (a, b) =>
      a.length === b.length &&
      a.every(
        (filter, index) =>
          filter.id === b[index]?.id &&
          filter.value === b[index]?.value &&
          filter.variant === b[index]?.variant &&
          filter.operator === b[index]?.operator,
      ),
  });
};

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Optimize Supabase Storage image URLs by adding transformation parameters
 * to reduce bandwidth and improve loading speeds
 */
export function optimizeImageUrl(
  url: string | null,
  options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'webp' | 'avif' | 'jpg' | 'png';
  } = {}
): string {
  if (!url || !url.includes('supabase')) {
    return url || '/placeholder.svg';
  }

  const { width, height, quality = 80, format = 'webp' } = options;

  // Add transformation parameters to Supabase Storage URLs
  const separator = url.includes('?') ? '&' : '?';
  let transformParams = `quality=${quality}&format=${format}`;

  if (width) transformParams += `&width=${width}`;
  if (height) transformParams += `&height=${height}`;

  return `${url}${separator}${transformParams}`;
}

================
File: src/locales/index.ts
================
import { en } from "./en";
import { rw } from "./rw";

export const translations = {
  en,
  rw,
};

export type Language = keyof typeof translations;

================
File: src/pages/api/admin/assign-order.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { assignOrderToRider } from "@/integrations/supabase/riders";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   const { orderId, riderId, notes } = req.body;
   if (!orderId || !riderId)
      return res.status(400).json({ error: "orderId and riderId required" });

   try {
      const assignment = await assignOrderToRider(orderId, riderId, notes);
      return res.status(200).json({ assignment });
   } catch (err: any) {
      console.error("assign-order failed", err);
      if (err && err.code === "ORDER_NOT_FOUND")
         return res
            .status(404)
            .json({ error: { code: err.code, message: err.message } });
      if (err && err.code === "RIDER_NOT_FOUND")
         return res
            .status(404)
            .json({ error: { code: err.code, message: err.message } });
      if (err && err.code === "RIDER_INACTIVE")
         return res
            .status(409)
            .json({ error: { code: err.code, message: err.message } });
      if (err && err.code === "ORDER_NOT_PENDING")
         return res
            .status(409)
            .json({ error: { code: err.code, message: err.message } });
      return res.status(500).json({
         error: {
            code: err.code || "INTERNAL_ERROR",
            message: err.message || "Failed to assign order",
         },
      });
   }
}

================
File: src/pages/api/admin/create-user.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // Avoid throwing during module initialization; APIs will return an error if env is missing
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase) {
      return res.status(500).json({
         error:
            "SUPABASE_SERVICE_ROLE_KEY or NEXT_PUBLIC_SUPABASE_URL is not configured on the server.\n" +
            "For local testing add SUPABASE_SERVICE_ROLE_KEY to your .env.local (get it from Supabase Dashboard > Project Settings > API > Service Key). Do NOT commit the real key.",
      });
   }
   const { email, password, fullName, phone, role } = req.body;
   if (!email || !password)
      return res.status(400).json({ error: "Email and password required" });
   // Create user in auth.users (service role)
   const { data, error } = await supabase.auth.admin.createUser({
      email,
      password,
      // Mark the user as confirmed so they can sign in immediately when created by an admin
      email_confirm: true,
      user_metadata: { full_name: fullName, phone, role },
   });
   if (error) return res.status(400).json({ error: error.message });

   const userId = data.user?.id;

   try {
      // Insert a profiles row so profiles has the full_name/phone and created_at
      if (userId) {
         const { error: profileError } = await supabase.from("profiles").upsert(
            [
               {
                  id: userId,
                  full_name: fullName || null,
                  phone: phone || null,
               },
            ],
            { onConflict: "id" }
         );
         if (profileError) {
            console.error(
               "Failed to upsert profile for new user:",
               profileError
            );
            // not fatal: continue but log
         }
      }

      // Optionally, insert into user_roles
      if (role && userId) {
         const { error: roleErr } = await supabase
            .from("user_roles")
            .upsert([{ user_id: userId, role }], {
               onConflict: "user_id,role",
            });
         if (roleErr) {
            console.error("Failed to upsert role for new user:", roleErr);
         }
      }

      res.status(200).json({ user: data.user });
   } catch (err: any) {
      console.error("create-user post-create steps failed", err);
      res.status(200).json({
         user: data.user,
         warning: "created user but failed to persist profile/role",
      });
   }
}

================
File: src/pages/api/admin/delete-rider.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { deleteRider } from "@/integrations/supabase/riders";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   const { riderId } = req.body || {};
   if (!riderId) return res.status(400).json({ error: "riderId required" });
   try {
      const data = await deleteRider(riderId);
      return res.status(200).json({ deleted: data ? true : false });
   } catch (err: any) {
      console.error("delete-rider failed", err);
      return res.status(500).json({ error: err?.message || String(err) });
   }
}

================
File: src/pages/api/admin/delete-user.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // avoid throwing during module init
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });

   const { userId, hardDelete } = req.body;
   if (!supabase) {
      return res.status(500).json({
         error:
            "SUPABASE_SERVICE_ROLE_KEY or NEXT_PUBLIC_SUPABASE_URL is not configured on the server.\n" +
            "For local testing add SUPABASE_SERVICE_ROLE_KEY to your .env.local (get it from Supabase Dashboard > Project Settings > API > Service Key). Do NOT commit the real key.",
      });
   }
   if (!userId) return res.status(400).json({ error: "userId is required" });

   try {
      // Remove role
      const { error: roleError } = await supabase
         .from("user_roles")
         .delete()
         .eq("user_id", userId);
      if (roleError) throw roleError;

      if (hardDelete) {
         // Optionally delete from auth (requires service role)
         const { error: authErr } = await supabase.auth.admin.deleteUser(
            userId
         );
         if (authErr) throw authErr;
      }

      res.status(200).json({ success: true });
   } catch (err: any) {
      console.error("delete-user failed", err);
      res.status(500).json({ error: err.message || "Failed to delete user" });
   }
}

================
File: src/pages/api/admin/import-riders.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { createRider } from "@/integrations/supabase/riders";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // do nothing
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   const { rows } = req.body || {};
   if (!Array.isArray(rows))
      return res
         .status(400)
         .json({ error: "Invalid payload, expected rows array" });

   const results: any[] = [];

   for (const r of rows) {
      const full_name = r.full_name || r.name || r.fullName || null;
      const phone = r.phone || null;
      const vehicle = r.vehicle || null;
      const email = r.email || null;
      const password = r.password || null;

      try {
         let createdUserId: string | null = null;
         if (email && password) {
            const { data, error } = await supabase.auth.admin.createUser({
               email,
               password,
               email_confirm: true,
               user_metadata: { full_name, phone, role: "rider" },
            });
            if (error) {
               results.push({ row: r, error: error.message });
               continue;
            }
            createdUserId = data.user?.id || null;

            // upsert role immediately
            try {
               await supabase
                  .from("user_roles")
                  .upsert([{ user_id: createdUserId, role: "rider" }], {
                     onConflict: "user_id,role",
                  });
            } catch (e) {
               console.error("Failed to upsert role for imported rider:", e);
            }

            // Ensure profile exists with provided metadata for immediate access
            if (createdUserId) {
               try {
                  const { error: profileErr } = await supabase
                     .from("profiles")
                     .upsert(
                        [
                           {
                              id: createdUserId,
                              full_name: full_name || null,
                              phone: phone || null,
                           },
                        ],
                        { onConflict: "id" }
                     );
                  if (profileErr)
                     console.error(
                        "Failed to upsert profile for imported rider:",
                        profileErr
                     );
               } catch (e) {
                  console.error(
                     "Error upserting profile for imported rider:",
                     e
                  );
               }
            }
         }

         // If the row already contains a user id, ensure the user_roles mapping
         // exists so client-side redirects work immediately after sign-in.
         if (!createdUserId && (r.user_id || r.userId)) {
            createdUserId = r.user_id || r.userId;
            try {
               await supabase
                  .from("user_roles")
                  .upsert([{ user_id: createdUserId, role: "rider" }], {
                     onConflict: "user_id,role",
                  });
            } catch (e) {
               console.error(
                  "Failed to upsert role for provided user_id in import:",
                  e
               );
            }
         }

         // Use existing integration to create rider record
         const rider = await createRider({
            full_name,
            phone,
            vehicle,
            user_id: createdUserId,
         });
         results.push({ row: r, rider });
      } catch (err: any) {
         results.push({ row: r, error: err?.message || String(err) });
      }
   }

   return res.status(200).json({ imported: results.length, results });
}

================
File: src/pages/api/admin/rider-assignments.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // Handler will return error if env missing
}

const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "GET")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   try {
      const idsParam = String(req.query.ids || "").trim();
      if (!idsParam)
         return res
            .status(400)
            .json({ error: "ids query parameter is required" });

      const ids = idsParam
         .split(",")
         .map((s) => s.trim())
         .filter(Boolean);
      if (ids.length === 0)
         return res.status(400).json({ error: "No rider ids provided" });

      // Fetch recent assignments for the given rider ids, ordered newest first.
      // We'll pick the first assignment per rider on the server response.
      const { data, error } = await supabase
         .from("order_assignments")
         .select("*, orders:orders(id, total, delivery_address, subtotal)")
         .in("rider_id", ids)
         .order("assigned_at", { ascending: false });

      if (error) {
         console.error("Error fetching rider assignments (admin):", error);
         return res.status(500).json({ error: error.message || error });
      }

      const assignments = (data || []) as any[];
      const map: Record<string, any> = {};
      for (const a of assignments) {
         const rid = a.rider_id;
         if (!map[rid]) map[rid] = a; // first (newest) wins
      }

      return res.status(200).json({ assignments: map });
   } catch (err: any) {
      console.error("rider-assignments handler failed", err);
      return res.status(500).json({ error: err?.message || "Failed" });
   }
}

================
File: src/pages/api/admin/rider-details.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // noop
}

const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "GET")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   const riderId = String(req.query.rid || "");
   if (!riderId) return res.status(400).json({ error: "rid is required" });

   try {
      const { data: rider, error: rerr } = await supabase
         .from("riders")
         .select("*")
         .eq("id", riderId)
         .maybeSingle();
      if (rerr) return res.status(500).json({ error: rerr.message || rerr });
      if (!rider) return res.status(404).json({ error: "Rider not found" });

      const { data: assignments, error: aerr } = await supabase
         .from("order_assignments")
         .select("*, orders:orders(*)")
         .eq("rider_id", riderId)
         .order("assigned_at", { ascending: false })
         .limit(20);
      if (aerr) return res.status(500).json({ error: aerr.message || aerr });

      return res.status(200).json({ rider, assignments: assignments || [] });
   } catch (err: any) {
      console.error("rider-details failed", err);
      return res.status(500).json({ error: err?.message || "Failed" });
   }
}

================
File: src/pages/api/admin/riders/top-amount.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // do nothing
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   // Simple in-memory cache to avoid repeated expensive DB aggregation when the
   // endpoint is hammered. TTL is short because values change as orders are
   // delivered, but caching for a few seconds protects the DB from request
   // storms while preserving near-real-time metrics.
   // Note: this uses module-level memory; in a multi-instance production
   // deployment you'd prefer an external cache (Redis) but this is a low-risk
   // mitigation for dev and single-instance deployments.
   const TTL_MS = 15 * 1000; // 15 seconds
   // @ts-ignore module level cache
   if (!(global as any).__topAmountCache) {
      // @ts-ignore
      (global as any).__topAmountCache = { ts: 0, data: null };
   }
   // @ts-ignore
   const cache = (global as any).__topAmountCache;
   if (Date.now() - cache.ts < TTL_MS && cache.data) {
      return res.status(200).json(cache.data);
   }
   if (req.method !== "GET")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   try {
      // Query completed assignments to count successful deliveries per rider
      const { data: assignments, error } = await supabase
         .from("order_assignments")
         .select("rider_id, status, orders:orders(id, status)")
         .eq("status", "completed");

      if (error) throw error;

      // Count successful deliveries per rider
      const deliveryCounts: Record<string, number> = {};
      console.debug(
         `top-amount: fetched ${
            Array.isArray(assignments) ? assignments.length : 0
         } completed assignments`
      );

      for (const assignment of (assignments || []) as any[]) {
         const riderId = assignment.rider_id;
         const order = assignment.orders;

         if (!riderId || !order) continue;

         // Only count if the order is also delivered
         if (order.status === "delivered") {
            deliveryCounts[riderId] = (deliveryCounts[riderId] || 0) + 1;
         }
      }

      // Find top rider by delivery count
      let topRiderId: string | null = null;
      let topDeliveryCount = 0;
      for (const [riderId, count] of Object.entries(deliveryCounts)) {
         if (count > topDeliveryCount) {
            topDeliveryCount = count;
            topRiderId = riderId;
         }
      }

      // If we couldn't compute a top rider, return a sensible fallback
      const result =
         !topRiderId && topDeliveryCount === 0
            ? { topRiderId: null, topAmount: 0, deliveryCount: 0 }
            : {
                 topRiderId,
                 topAmount: topDeliveryCount,
                 deliveryCount: topDeliveryCount,
              };

      // Update cache before returning
      cache.ts = Date.now();
      cache.data = result;

      return res.status(200).json(result);
   } catch (err: any) {
      console.error("top-amount failed", err);
      return res.status(500).json({ error: err?.message || String(err) });
   }
}

================
File: src/pages/api/admin/update-rider-media.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // noop
}

const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   try {
      // Validate admin from Authorization header (Supabase JWT)
      const authHeader = String(req.headers.authorization || "");
      const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";
      if (!token) return res.status(401).json({ error: "Unauthorized" });

      const { data: userResp, error: userErr } = await supabase.auth.getUser(
         token as any
      );
      if (userErr || !userResp?.user) {
         return res.status(401).json({ error: "Invalid token" });
      }
      const userId = userResp.user.id;

      // Check role in user_roles table
      const { data: roles, error: roleErr } = await supabase
         .from("user_roles")
         .select("role")
         .eq("user_id", userId);
      if (roleErr)
         return res.status(500).json({ error: roleErr.message || roleErr });
      const isAdmin =
         Array.isArray(roles) && roles.some((r: any) => r.role === "admin");
      if (!isAdmin) return res.status(403).json({ error: "Forbidden" });

      const { riderId, imageUrl, location } = req.body || {};
      if (!riderId) return res.status(400).json({ error: "riderId required" });

      const updates: Record<string, any> = {};
      if (typeof imageUrl === "string") updates.image_url = imageUrl;
      if (typeof location === "string") updates.location = location;

      const { data: rider, error } = await supabase
         .from("riders")
         .update(updates)
         .eq("id", riderId)
         .select("*")
         .single();
      if (error) return res.status(500).json({ error: error.message || error });

      return res.status(200).json({ rider });
   } catch (err: any) {
      console.error("update-rider-media failed", err);
      return res.status(500).json({ error: err?.message || "Failed" });
   }
}

================
File: src/pages/api/admin/update-rider.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { updateRider } from "@/integrations/supabase/riders";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   const { riderId, updates } = req.body || {};
   if (!riderId) return res.status(400).json({ error: "riderId required" });
   try {
      const rider = await updateRider(riderId, updates || {});
      return res.status(200).json({ rider });
   } catch (err: any) {
      console.error("update-rider failed", err);
      return res.status(500).json({ error: err?.message || String(err) });
   }
}

================
File: src/pages/api/admin/update-user-role.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // avoid throwing during module init
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });

   const { userId, role } = req.body;
   if (!supabase) {
      return res.status(500).json({
         error:
            "SUPABASE_SERVICE_ROLE_KEY or NEXT_PUBLIC_SUPABASE_URL is not configured on the server.\n" +
            "For local testing add SUPABASE_SERVICE_ROLE_KEY to your .env.local (get it from Supabase Dashboard > Project Settings > API > Service Key). Do NOT commit the real key.",
      });
   }
   if (!userId || !role)
      return res.status(400).json({ error: "userId and role are required" });

   try {
      const { error } = await supabase
         .from("user_roles")
         .upsert([{ user_id: userId, role }], { onConflict: "user_id,role" });
      if (error) throw error;
      res.status(200).json({ success: true });
   } catch (err: any) {
      console.error("update-user-role failed", err);
      res.status(500).json({ error: err.message || "Failed to update role" });
   }
}

================
File: src/pages/api/admin/upload-rider-image.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

export const config = {
   api: {
      bodyParser: {
         sizeLimit: "10mb",
      },
   },
};

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // noop
}

const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   try {
      const authHeader = String(req.headers.authorization || "");
      const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";
      if (!token) return res.status(401).json({ error: "Unauthorized" });

      const { data: userResp, error: userErr } = await supabase.auth.getUser(
         token as any
      );
      if (userErr || !userResp?.user) {
         return res.status(401).json({ error: "Invalid token" });
      }
      const userId = userResp.user.id;

      const { data: roles, error: roleErr } = await supabase
         .from("user_roles")
         .select("role")
         .eq("user_id", userId);
      if (roleErr)
         return res.status(500).json({ error: roleErr.message || roleErr });
      const isAdmin =
         Array.isArray(roles) && roles.some((r: any) => r.role === "admin");
      if (!isAdmin) return res.status(403).json({ error: "Forbidden" });

      const { filename, base64 } = req.body || {};
      if (!filename || !base64)
         return res.status(400).json({ error: "filename and base64 required" });

      const buffer = Buffer.from(base64, "base64");
      const objectPath = `${Date.now()}-${filename}`;
      const { error: upErr } = await (supabase as any).storage
         .from("rider-images")
         .upload(objectPath, buffer, {
            contentType: "application/octet-stream",
            upsert: false,
         });
      if (upErr) return res.status(400).json({ error: upErr.message || upErr });
      const { data } = (supabase as any).storage
         .from("rider-images")
         .getPublicUrl(objectPath);

      return res.status(200).json({ url: data?.publicUrl });
   } catch (err: any) {
      console.error("upload-rider-image failed", err);
      return res.status(500).json({ error: err?.message || "Failed" });
   }
}

================
File: src/pages/api/announcement.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

const supabase =
  process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
    ? createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.SUPABASE_SERVICE_ROLE_KEY
      )
    : (null as any);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (!supabase)
    return res.status(500).json({ error: "Supabase not configured" });

  if (req.method === "GET") {
    // Get the latest announcement
    const { data, error } = await supabase
      .from("announcements")
      .select("announcement")
      .order("updated_at", { ascending: false })
      .limit(1)
      .single();

    if (error) {
      return res.status(500).json({ error: error.message });
    }
    return res
      .status(200)
      .json({
        announcement:
          data?.announcement || "Due to Rainy season it will affect delivery",
      });
  }

  if (req.method === "POST") {
    const { announcement } = req.body;
    if (typeof announcement !== "string" || !announcement.trim()) {
      return res.status(400).json({ error: "Invalid announcement" });
    }
    // Insert new announcement (or update the latest one)
    const { error } = await supabase
      .from("announcements")
      .insert({ announcement });

    if (error) {
      return res.status(500).json({ error: error.message });
    }
    return res.status(200).json({ announcement });
  }

  res.setHeader("Allow", ["GET", "POST"]);
  res.status(405).end(`Method ${req.method} Not Allowed`);
}

================
File: src/pages/api/auth/upsert-profile.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // do nothing at module init; handler will return 500
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase) {
      return res
         .status(500)
         .json({
            error: "SUPABASE_SERVICE_ROLE_KEY or NEXT_PUBLIC_SUPABASE_URL not configured on server",
         });
   }

   const { userId, full_name, phone } = req.body || {};
   if (!userId) return res.status(400).json({ error: "userId is required" });

   try {
      const { error } = await supabase.from("profiles").upsert(
         [
            {
               id: userId,
               full_name: full_name || null,
               phone: phone || null,
            },
         ],
         { onConflict: "id" }
      );

      if (error) {
         console.error("upsert-profile failed:", error);
         return res.status(500).json({ error: error.message });
      }

      return res.status(200).json({ ok: true });
   } catch (err: any) {
      console.error("upsert-profile error:", err);
      return res.status(500).json({ error: err?.message || String(err) });
   }
}

================
File: src/pages/api/notifications/index.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op - handler will report error
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   try {
      if (req.method === "GET") {
         const { userId, role, limit = 50, notificationId, since } = req.query;

         // If a notificationId is provided, return that single notification
         if (notificationId) {
            const { data, error } = await supabase
               .from("notifications")
               .select("*")
               .eq("id", String(notificationId))
               .limit(1);
            if (error) {
               console.error("fetch notification error:", error);
               return res.status(500).json({ error: error.message || error });
            }
            return res
               .status(200)
               .json({ notification: (data && data[0]) || null });
         }

         let query = supabase
            .from("notifications")
            .select("*")
            .order("created_at", { ascending: false })
            .limit(Number(limit));

         if (userId) query = query.eq("recipient_user_id", String(userId));
         if (role) query = query.eq("recipient_role", String(role));
         if (since) query = query.gt("created_at", String(since));

         const { data, error } = await query;
         if (error) {
            console.error("fetch notifications error:", error);
            return res.status(500).json({ error: error.message || error });
         }

         return res.status(200).json({ notifications: data || [] });
      }

      return res.status(405).json({ error: "Method not allowed" });
   } catch (err: any) {
      console.error("notifications handler error", err);
      return res.status(500).json({ error: err.message || err });
   }
}

================
File: src/pages/api/notifications/mark-read.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });

   if (req.method !== "POST")
      return res.status(405).json({ error: "Method not allowed" });

   const { ids } = req.body;
   if (!ids || !Array.isArray(ids))
      return res.status(400).json({ error: "ids array required" });

   try {
      const { data, error } = await supabase
         .from("notifications")
         .update({ read: true })
         .in("id", ids)
         .select();
      if (error) {
         console.error("mark read error", error);
         return res.status(500).json({ error: error.message || error });
      }
      return res.status(200).json({ updated: data });
   } catch (err: any) {
      console.error(err);
      return res.status(500).json({ error: err.message || err });
   }
}

================
File: src/pages/api/rider/assignments.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // Handler will return error if env missing
}

const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);

export default async function handler(
   req: NextApiRequest,
   res: NextApiResponse
) {
   if (req.method !== "GET")
      return res.status(405).json({ error: "Method not allowed" });
   if (!supabase)
      return res.status(500).json({ error: "Supabase not configured" });
   // Require a valid supabase access token in the Authorization header. This
   // endpoint is intended for rider clients; admin UIs should use the
   // `/api/admin/rider-assignments` batched endpoint instead.
   const authHeader = String(req.headers.authorization || "");
   const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";
   if (!token)
      return res.status(401).json({ error: "Authorization token required" });

   try {
      // Validate token and retrieve user
      const { data: userData, error: userErr } = await supabase.auth.getUser(
         token as string as any
      );
      if (userErr || !userData?.user) {
         console.error("Invalid token for rider assignments", userErr);
         return res.status(401).json({ error: "Invalid token" });
      }
      const user = userData.user;

      const riderId = String(req.query.riderId || "");
      if (!riderId)
         return res.status(400).json({ error: "riderId is required" });

      // Ensure the rider exists and is owned by the authenticated user. This
      // prevents arbitrary clients (including admin pages) from enumerating
      // assignments for other riders: admins should use the admin batch API.
      const { data: riderRow, error: riderErr } = await supabase
         .from("riders")
         .select("id, user_id")
         .eq("id", riderId)
         .maybeSingle();
      if (riderErr) {
         console.error("Error fetching rider for auth check:", riderErr);
         return res.status(500).json({ error: riderErr.message || riderErr });
      }
      if (!riderRow) return res.status(404).json({ error: "Rider not found" });
      if (!riderRow.user_id || riderRow.user_id !== user.id) {
         return res.status(403).json({ error: "Forbidden" });
      }

      const { data, error } = await supabase
         .from("order_assignments")
         .select("*, orders:orders(*, items:order_items(*))")
         .eq("rider_id", riderId)
         .order("assigned_at", { ascending: false });

      if (error) {
         console.error("Error fetching assignments (service):", error);
         return res.status(500).json({ error: error.message || error });
      }

      return res.status(200).json({ assignments: data || [] });
   } catch (err: any) {
      console.error("assignments handler failed", err);
      return res.status(500).json({ error: err?.message || "Failed" });
   }
}

================
File: src/pages/api/rider/respond-assignment.ts
================
import type { NextApiRequest, NextApiResponse } from "next";
import { respondToAssignment } from "@/integrations/supabase/riders";
import { createClient } from "@supabase/supabase-js";

if (
   !process.env.NEXT_PUBLIC_SUPABASE_URL ||
   !process.env.SUPABASE_SERVICE_ROLE_KEY
) {
   // no-op
}
const supabase =
   process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY
      ? createClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL,
           process.env.SUPABASE_SERVICE_ROLE_KEY
        )
      : (null as any);


================
File: src/app/api/payments/retry/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import {
   initializeKPayService,
   KPayService,
   PAYMENT_METHODS,
} from "@/lib/services/kpay";
import { createServerSupabaseClient } from "@/utils/supabase/server";
import { logger } from "@/lib/logger";

interface RetryRequest {
   orderId: string;
   amount: number;
   customerName: string;
   customerEmail: string;
   customerPhone: string;
   paymentMethod: keyof typeof PAYMENT_METHODS;
   redirectUrl: string;
}

export async function POST(request: NextRequest) {
   let orderId: string | undefined;
   try {
      const body: RetryRequest = await request.json();
      orderId = body.orderId;

      if (!body.orderId || !body.amount || !body.paymentMethod) {
         return NextResponse.json(
            { error: "Missing required fields" },
            { status: 400 }
         );
      }

      const supabase = await createServerSupabaseClient();

      // Fetch the latest payment for this order
      const { data: latestPayment } = await supabase
         .from("payments")
         .select("id, status, client_timeout, created_at")
         .eq("order_id", body.orderId)
         .order("created_at", { ascending: false })
         .limit(1)
         .single();

      if (latestPayment) {
         if (
            latestPayment.status === "completed" ||
            latestPayment.status === "successful"
         ) {
            return NextResponse.json(
               { error: "Order already paid" },
               { status: 400 }
            );
         }

         if (
            latestPayment.status === "pending" &&
            !latestPayment.client_timeout
         ) {
            return NextResponse.json(
               {
                  error: "Existing payment in progress. Please wait or try after timeout.",
               },
               { status: 409 }
            );
         }
      }

      // Initialize KPay service
      const kpayService = initializeKPayService();

      const orderReference = KPayService.generateOrderReference();
      const formattedPhone = KPayService.formatPhoneNumber(body.customerPhone);

      // Create a new payment record with a simple retry on transient DB errors
      let payment: any = null;
      let paymentError: any = null;
      for (let attempt = 1; attempt <= 2; attempt++) {
         const res = await supabase
            .from("payments")
            .insert({
               order_id: body.orderId,
               amount: body.amount,
               currency: "RWF",
               payment_method: body.paymentMethod,
               status: "pending",
               reference: orderReference,
               customer_name: body.customerName,
               customer_email: body.customerEmail,
               customer_phone: formattedPhone,
               created_at: new Date().toISOString(),
            })
            .select()
            .single();

         payment = (res as any).data;
         paymentError = (res as any).error;

         if (!paymentError && payment) break;

         // small backoff
         await new Promise((r) => setTimeout(r, 150 * attempt));
      }

      if (paymentError || !payment) {
         const errMsg = paymentError
            ? paymentError.message || String(paymentError)
            : "no-data";
         logger.error("api", "Failed to create retry payment record", {
            orderId: body.orderId,
            error: errMsg,
         });

         // Handle duplicate key on order_id: return existing payment so client can proceed
         if (
            errMsg.includes("duplicate key value") ||
            errMsg.includes("payments_order_id_key")
         ) {
            try {
               const { data: existing } = await supabase
                  .from("payments")
                  .select(
                     "id, status, kpay_transaction_id, reference, kpay_response"
                  )
                  .eq("order_id", body.orderId)
                  .order("created_at", { ascending: false })
                  .limit(1)
                  .single();

               if (existing) {
                  return NextResponse.json({
                     success: true,
                     paymentId: existing.id,
                     transactionId: existing.kpay_transaction_id,
                     checkoutUrl: existing.kpay_response?.url || null,
                     status: existing.status || "pending",
                  });
               }
            } catch (fetchErr) {
               logger.warn(
                  "api",
                  "Failed to fetch existing payment after duplicate key",
                  {
                     orderId: body.orderId,
                     error:
                        fetchErr instanceof Error
                           ? fetchErr.message
                           : String(fetchErr),
                  }
               );
            }
         }

         // Temporarily return technical error to help diagnose production issue
         return NextResponse.json(
            {
               error: "Failed to create payment record",
               technicalError: errMsg,
            },
            { status: 500 }
         );
      }

      // Initiate payment with KPay
      const kpayResponse = await kpayService.initiatePayment({
         amount: body.amount,
         customerName: body.customerName,
         customerEmail: body.customerEmail,
         customerPhone: formattedPhone,
         customerNumber: "",
         paymentMethod: body.paymentMethod,
         orderReference,
         orderDetails: `Order #${body.orderId} retry payment`,
         redirectUrl: body.redirectUrl,
         logoUrl: `${request.nextUrl.origin}/logo.png`,
      });

      // Update payment record with kpay info
      await supabase
         .from("payments")
         .update({
            kpay_transaction_id: kpayResponse.tid,
            kpay_auth_key: kpayResponse.authkey,
            kpay_return_code: kpayResponse.retcode,
            kpay_response: kpayResponse,
            updated_at: new Date().toISOString(),
         })
         .eq("id", payment.id);

      if (kpayResponse.retcode === 0) {
         return NextResponse.json({
            success: true,
            paymentId: payment.id,
            transactionId: kpayResponse.tid,
            checkoutUrl: kpayResponse.url,
            status: "pending",
         });
      }

      // On failure to initiate
      const errorMessage = kpayService.getErrorMessage(kpayResponse.retcode);
      await supabase
         .from("payments")
         .update({
            status: "failed",
            failure_reason: errorMessage,
            updated_at: new Date().toISOString(),
         })
         .eq("id", payment.id);

      return NextResponse.json(
         { success: false, error: errorMessage },
         { status: 400 }
      );
   } catch (error) {
      logger.error("api", "Retry payment failed", {
         orderId,
         error: error instanceof Error ? error.message : String(error),
      });
      return NextResponse.json(
         { error: "Internal server error" },
         { status: 500 }
      );
   }
}

export async function GET() {
   return NextResponse.json({ error: "Method not allowed" }, { status: 405 });
}

================
File: src/integrations/supabase/stock.ts
================
import { supabase } from "@/integrations/supabase/client";

const sb = supabase as any;

export interface StockProduct {
    id: string;
    name: string;
    price?: number;
    stock?: number;
    main_image_url?: string | null;
    category?: {
        id: string;
        name: string;
    } | null;
    variations: {
        id: string;
        name: string | null;
        stock: number;
        price?: number;
        attributes: Record<string, string>;
    }[];
}

export interface StockHistoryItem {
    id: string;
    created_at: string;
    change: number;
    new_quantity: number;
    reason: string | null;
    user: {
        full_name: string | null;
    } | null;
}

export async function fetchProductsForStockManagement(search: string = ''): Promise<StockProduct[]> {
    let query = sb
        .from('products')
        .select('id, name, main_image_url, price, stock, category:categories(id, name), variations:product_variations(id, name, stock, attributes, price)')
        .order('name');

    if (search.trim()) {
        query = query.ilike('name', `%${search.trim()}%`);
    }

    const { data, error } = await query.limit(1000_000); // Limit for performance
    if (error) throw error;
    return data as StockProduct[];
}

export async function fetchStockHistory(variationId: string): Promise<StockHistoryItem[]> {
    const { data, error } = await sb
        .from('stock_history')
        .select('*, user:profiles(full_name)')
        .eq('product_variation_id', variationId)
        .order('created_at', { ascending: false });

    if (error) throw error;
    return data as StockHistoryItem[];
}


export async function updateStockLevel({
    productId,
    variationId,
    change,
    reason
}: {
    productId: string;
    variationId: string;
    change: number;
    reason: string;
}): Promise<number> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User not authenticated");

    const { data, error } = await sb.rpc('update_stock_and_log', {
        product_id_in: productId,
        variation_id_in: variationId,
        change_in: change,
        reason_in: reason,
        user_id_in: user.id
    });

    if (error) throw error;
    return data;
}

export interface StockHistoryWithDetails {
    id: string;
    created_at: string;
    change: number;
    new_quantity: number;
    reason: string | null;
    product: {
        id: string;
        name: string;
    } | null;
    variation: {
        id: string;
        name: string | null;
    } | null;
    user: {
        id: string;
        full_name: string | null;
    } | null;
}

export async function fetchAllStockHistory({
    search = '',
    productId,
    userId,
    dateFrom,
    dateTo,
    limit = 50,
    offset = 0
}: {
    search?: string;
    productId?: string;
    userId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
} = {}): Promise<{ data: StockHistoryWithDetails[], count: number }> {
    let query = sb
        .from('stock_history')
        .select(`
            id,
            created_at,
            change,
            new_quantity,
            reason,
            product:products(id, name),
            variation:product_variations(id, name),
            user:profiles(id, full_name)
        `, { count: 'exact' })
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

    if (productId) {
        query = query.eq('product_id', productId);
    }

    if (userId) {
        query = query.eq('user_id', userId);
    }

    if (dateFrom) {
        query = query.gte('created_at', dateFrom);
    }

    if (dateTo) {
        query = query.lte('created_at', dateTo);
    }

    if (search.trim()) {
        query = query.ilike('reason', `%${search}%`);
    }

    const { data, error, count } = await query;

    if (error) throw error;
    return {
        data: data as StockHistoryWithDetails[],
        count: count || 0
    };
}

export async function updateProductStock({
    productId,
    change,
    reason
}: {
    productId: string;
    change: number;
    reason: string;
}): Promise<number> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("User not authenticated");

    // Get current stock
    const { data: product, error: fetchError } = await sb
        .from('products')
        .select('stock')
        .eq('id', productId)
        .single();

    if (fetchError) throw fetchError;

    const currentStock = product.stock || 0;
    const newStock = currentStock + change;

    // Update stock
    const { error: updateError } = await sb
        .from('products')
        .update({ stock: newStock, updated_at: 'now()' })
        .eq('id', productId);

    if (updateError) throw updateError;

    // Log the change
    const { error: logError } = await sb
        .from('stock_history')
        .insert({
            product_id: productId,
            product_variation_id: null,
            user_id: user.id,
            change,
            new_quantity: newStock,
            reason
        });

    if (logError) throw logError;

    return newStock;
}

export async function fetchProductStockHistory(productId: string): Promise<StockHistoryItem[]> {
    const { data, error } = await sb
        .from('stock_history')
        .select('*, user:profiles(full_name)')
        .eq('product_id', productId)
        .is('product_variation_id', null)
        .order('created_at', { ascending: false });

    if (error) throw error;
    return data as StockHistoryItem[];
}

================
File: src/app/sitemap.xml/route.ts
================
import { NextResponse } from "next/server";

const BASE_URL = process.env.NEXT_PUBLIC_SITE_URL || "https://nihemart.rw";

// Manual list of public pages to include in the sitemap.
// Add or remove routes here as you publish/unpublish pages.
const PAGES = [
   "/",
   "/about",
   "/products",
   "/how-to-buy",
   "/contact",
   "/cart",
   "/checkout",
   "/wishlist",
   "/profile",
   "/orders",
   "/returns",
   "/addresses",
   "/signin",
   "/signup",
   "/forgot-password",
   "/reset-password",
];

export async function GET() {
   const urls = PAGES.map((p) => `${BASE_URL}${p}`);

   const xml =
      `<?xml version="1.0" encoding="UTF-8"?>\n` +
      `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n` +
      urls.map((url) => `  <url>\n    <loc>${url}</loc>\n  </url>`).join("\n") +
      `\n</urlset>`;

   return new NextResponse(xml, {
      headers: {
         "Content-Type": "application/xml",
      },
   });
}

================
File: src/assets/index.ts
================
export { default as profilePlaceholder } from "./imgs/profile-placeholder.png";
export { default as carousel1 } from "./carousel-imgs/1.webp";
export { default as carousel2 } from "./carousel-imgs/2.webp";
export { default as carousel3 } from "./carousel-imgs/3.webp";
export { default as carousel4 } from "./carousel-imgs/4.webp";
export { default as carousel5 } from "./carousel-imgs/5.jpg";
export { default as aboutImg } from './imgs/about.jpg'

// Icons
export { default as momoIcon } from "./icons/mtn.png";
export { default as mtnIcon } from "./icons/mtn.png";
export { default as airtelIcon } from "./icons/airtel.png";
export { default as visaIcon } from "./icons/visa.png";
export { default as codIcon } from "./icons/cod.png";

================
File: src/hooks/useUsers.ts
================
"use client";

import { useState, useCallback, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";

export type AppRole = "admin" | "user";
export interface UserRow {
   id: string;
   email: string;
   full_name?: string;
   phone?: string;
   created_at?: string;
   role?: AppRole;
   orderCount?: number;
   totalSpend?: number;
}

export function useUsers() {
   const [users, setUsers] = useState<UserRow[]>([]);
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState<string | null>(null);
   const [page, setPage] = useState<number>(1);
   const [limit, setLimit] = useState<number>(50);
   const [totalCount, setTotalCount] = useState<number | null>(null);

   // Fetch all users from profiles and merge with emails from admin API
   const fetchUsers = useCallback(
      async (p: number = page, l: number = limit) => {
         setLoading(true);
         setError(null);
         // 1. Fetch profiles
         // Fetch profiles for the current page range. We still fetch profiles for
         // the requested page window to avoid loading every profile on large
         // datasets. The admin API will return a paginated union of auth/profiles
         // and aggregates that we merge with the profile rows we fetched.
         const start = (p - 1) * l;
         const end = start + l - 1;
         const { data: profiles, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name, phone, created_at")
            .range(start, end);
         if (profilesError) {
            setError(profilesError.message);
            setLoading(false);
            return;
         }
         // 2. Fetch enriched users from API route (order aggregates + email + role)
         let enriched: any[] = [];
         let apiCount: number | null = null;
         try {
            const q = new URLSearchParams();
            q.set("page", String(p));
            q.set("limit", String(l));
            const res = await fetch(`/api/admin/list-users?${q.toString()}`);
            if (res.ok) {
               const json = await res.json();
               enriched = json.users || [];
               apiCount = typeof json.count === "number" ? json.count : null;
            }
         } catch (e) {
            // ignore, fallback to profiles only
         }

         // 3. Merge by id to produce UserRow[] with aggregates.
         // Also include any users returned by the enriched API that don't have a
         // corresponding profile row (enriched-only). This ensures we show all
         // users available to the admin API.
         const profilesArr: any[] = (profiles as any[]) || [];
         const mergedById: Record<string, UserRow> = {};

         // Start with profiles
         for (const p of profilesArr) {
            mergedById[p.id] = {
               id: p.id,
               email: "",
               full_name: p.full_name,
               phone: p.phone,
               created_at: p.created_at,
               role: "user",
               orderCount: 0,
               totalSpend: 0,
            };
         }

         // Merge/enrich with API data
         for (const e of enriched) {
            if (!e || !e.id) continue;
            const existing = mergedById[e.id];
            mergedById[e.id] = {
               id: e.id,
               email: e.email || existing?.email || "",
               full_name: existing?.full_name || e.full_name || "",
               phone: existing?.phone || e.phone || "",
               created_at: existing?.created_at || e.created_at || undefined,
               role: (e.role as AppRole) || existing?.role || "user",
               orderCount: Number(e.order_count || existing?.orderCount || 0),
               totalSpend: Number(e.total_spend || existing?.totalSpend || 0),
            };
         }

         const users: UserRow[] = Object.values(mergedById);
         setUsers(users);
         setTotalCount(apiCount ?? users.length);
         setLoading(false);
      },
      []
   );

   // Auto-fetch when the hook is used in a client component so multiple
   // components don't need to call fetchUsers manually. This keeps the UX
   // simpler: components that need users will mount the hook and get data.
   useEffect(() => {
      // Fetch current page when hook mounts or page/limit changes
      fetchUsers(page, limit);
      // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [page, limit]);

   // Update user role
   const updateUserRole = useCallback(
      async (userId: string, role: AppRole) => {
         setLoading(true);
         setError(null);
         try {
            const res = await fetch("/api/admin/update-user-role", {
               method: "POST",
               headers: { "Content-Type": "application/json" },
               body: JSON.stringify({ userId, role }),
            });
            if (!res.ok) {
               const json = await res.json();
               throw new Error(json.error || "Failed to update role");
            }
            await fetchUsers();
         } catch (err: any) {
            setError(err.message || "Failed to update role");
         } finally {
            setLoading(false);
         }
      },
      [fetchUsers]
   );

   // Delete user (soft delete by disabling or hard delete)
   const deleteUser = useCallback(
      async (userId: string, hardDelete = false) => {
         setLoading(true);
         setError(null);
         try {
            const res = await fetch("/api/admin/delete-user", {
               method: "POST",
               headers: { "Content-Type": "application/json" },
               body: JSON.stringify({ userId, hardDelete }),
            });
            if (!res.ok) {
               const json = await res.json();
               throw new Error(json.error || "Failed to delete user");
            }
            await fetchUsers();
         } catch (err: any) {
            setError(err.message || "Failed to delete user");
         } finally {
            setLoading(false);
         }
      },
      [fetchUsers]
   );

   return {
      users,
      loading,
      error,
      fetchUsers,
      page,
      limit,
      setPage,
      setLimit,
      totalCount,
      updateUserRole,
      deleteUser,
   };
}

================
File: src/integrations/supabase/products.ts
================
import { supabase } from "@/integrations/supabase/client";

const sb = supabase as any;

export type ProductStatus = "active" | "draft" | "out_of_stock";

export interface ProductBase {
   name: string;
   description?: string | null;
   short_description?: string | null;
   price: number;
   compare_at_price?: number | null;
   cost_price?: number | null;
   sku?: string | null;
   barcode?: string | null;
   weight_kg?: number | null;
   dimensions?: string | null;
   category_id?: string | null;
   subcategory_id?: string | null;
   categories?: string[];
   subcategories?: string[];
   brand?: string | null;
   tags?: string[] | null;
   featured?: boolean;
   status?: ProductStatus;
   track_quantity?: boolean;
   continue_selling_when_oos?: boolean;
   requires_shipping?: boolean;
   taxable?: boolean;
   stock?: number;
   main_image_url?: string | null;
}

export interface Product
   extends Omit<ProductBase, "categories" | "subcategories"> {
   id: string;
   created_at: string;
   updated_at: string;
   category?: { id: string; name: string } | null;
   subcategory?: { id: string; name: string } | null;
   categories?: { id: string; name: string }[];
   subcategories?: { id: string; name: string }[];
}

export interface ProductImage {
   id: string;
   product_id: string;
   product_variation_id?: string | null;
   url: string;
   is_primary: boolean;
   position: number;
}

export interface ProductVariation {
   id?: string;
   product_id?: string;
   price?: number | null;
   stock?: number;
   sku?: string | null;
   barcode?: string | null;
   attributes: Record<string, string>;
   images?: ProductImage[];
}

export interface ProductVariationInput
   extends Omit<ProductVariation, "images"> {
   imageFiles?: File[];
   existingImages?: ProductImage[];
}

export interface Category {
   id: string;
   name: string;
}
export interface Subcategory {
   id: string;
   name: string;
   category_id: string;
}
export interface CategoryWithSubcategories extends Category {
   subcategories: Subcategory[];
}

export interface ProductListPageFilters {
   search?: string;
   category?: string;
   status?: ProductStatus | "all";
}

export interface ProductQueryOptions {
   filters?: ProductListPageFilters;
   pagination?: {
      page: number;
      limit: number;
   };
   sort?: {
      column: string;
      direction: "asc" | "desc";
   };
}

const uploadFile = async (file: File, bucket: string): Promise<string> => {
   const filePath = `${Date.now()}-${file.name}`;
   const { error } = await sb.storage.from(bucket).upload(filePath, file);
   if (error) throw error;
   const { data } = sb.storage.from(bucket).getPublicUrl(filePath);
   return data.publicUrl;
};

export async function createProductWithImages(
   productData: ProductBase,
   mainImageFiles: File[],
   variationsData: ProductVariationInput[],
   selectedMainImageIndex: number = 0
) {
   const { categories, subcategories, ...productDataWithoutJunctions } =
      productData;

   const mainImageUrls = await Promise.all(
      mainImageFiles.map((file) => uploadFile(file, "product-images"))
   );
   if (mainImageUrls.length > 0) {
      productDataWithoutJunctions.main_image_url =
         mainImageUrls[selectedMainImageIndex] || mainImageUrls[0];
   }

   const { data: createdProduct, error: productError } = await sb
      .from("products")
      .insert(productDataWithoutJunctions)
      .select()
      .single();
   if (productError) throw productError;

   // Insert into junction tables
   if (categories && categories.length > 0) {
      const categoryInserts = categories.map((catId) => ({
         product_id: createdProduct.id,
         category_id: catId,
      }));
      const { error: catError } = await sb
         .from("product_categories")
         .insert(categoryInserts);
      if (catError) throw catError;
   }

   if (subcategories && subcategories.length > 0) {
      const subcategoryInserts = subcategories.map((subId) => ({
         product_id: createdProduct.id,
         subcategory_id: subId,
      }));
      const { error: subError } = await sb
         .from("product_subcategories")
         .insert(subcategoryInserts);
      if (subError) throw subError;
   }

   if (mainImageUrls.length > 0) {
      const mainImagesToInsert = mainImageUrls.map((url, index) => ({
         product_id: createdProduct.id,
         url,
         position: index,
         is_primary: index === selectedMainImageIndex,
      }));
      const { error: mainImagesError } = await sb
         .from("product_images")
         .insert(mainImagesToInsert);
      if (mainImagesError) throw mainImagesError;
   }

   for (const variation of variationsData) {
      const { imageFiles = [], ...variationDetails } = variation;
      const { data: createdVariation, error: variationError } = await sb
         .from("product_variations")
         .insert({ ...variationDetails, product_id: createdProduct.id })
         .select("id")
         .single();
      if (variationError) throw variationError;

      if (imageFiles.length > 0) {
         const variantImageUrls = await Promise.all(
            imageFiles.map((file) => uploadFile(file, "product-images"))
         );
         const variantImagesToInsert = variantImageUrls.map((url, index) => ({
            product_id: createdProduct.id,
            product_variation_id: createdVariation.id,
            url,
            position: index,
         }));
         const { error: variantImagesError } = await sb
            .from("product_images")
            .insert(variantImagesToInsert);
         if (variantImagesError) throw variantImagesError;
      }
   }
   return createdProduct;
}

export async function updateProductWithImages(
   productId: string,
   productData: Partial<ProductBase>,
   mainImages: { url: string; file?: File; isExisting?: boolean }[],
   variationsData: ProductVariationInput[],
   selectedMainImageIndex: number = 0
) {
   console.log("updateProductWithImages called", {
      productId,
      productData,
      mainImagesLength: mainImages.length,
      variationsDataLength: variationsData.length,
   });

   const { categories, subcategories, ...productDataWithoutJunctions } =
      productData;

   await sb.from("product_variations").delete().eq("product_id", productId);
   await sb
      .from("product_images")
      .delete()
      .eq("product_id", productId)
      .neq("product_variation_id", null);

   // Update junction tables
   if (categories !== undefined) {
      await sb.from("product_categories").delete().eq("product_id", productId);
      if (categories.length > 0) {
         const categoryInserts = categories.map((catId) => ({
            product_id: productId,
            category_id: catId,
         }));
         const { error: catError } = await sb
            .from("product_categories")
            .insert(categoryInserts);
         if (catError) throw catError;
      }
   }

   if (subcategories !== undefined) {
      await sb
         .from("product_subcategories")
         .delete()
         .eq("product_id", productId);
      if (subcategories.length > 0) {
         const subcategoryInserts = subcategories.map((subId) => ({
            product_id: productId,
            subcategory_id: subId,
         }));
         const { error: subError } = await sb
            .from("product_subcategories")
            .insert(subcategoryInserts);
         if (subError) throw subError;
      }
   }

   // Separate existing and new images
   const existingImages = mainImages.filter((img) => img.isExisting);
   const newFiles = mainImages
      .filter((img) => img.file)
      .map((img) => img.file!);

   // URLs to keep
   const urlsToKeep = existingImages.map((img) => img.url);

   // Delete removed main images
   if (urlsToKeep.length > 0) {
      await sb
         .from("product_images")
         .delete()
         .eq("product_id", productId)
         .is("product_variation_id", null)
         .not(
            "url",
            "in",
            `(${urlsToKeep.map((url) => `"${url}"`).join(",")})`
         );
   } else {
      await sb
         .from("product_images")
         .delete()
         .eq("product_id", productId)
         .is("product_variation_id", null);
   }

   // Upload new files
   const newImageUrls = await Promise.all(
      newFiles.map((file) => uploadFile(file, "product-images"))
   );

   // Update is_primary for kept existing images
   for (let i = 0; i < existingImages.length; i++) {
      const shouldBePrimary = i === selectedMainImageIndex;
      await sb
         .from("product_images")
         .update({ is_primary: shouldBePrimary })
         .eq("url", existingImages[i].url)
         .eq("product_id", productId);
   }

   // Set main_image_url based on selected image
   if (mainImages.length > 0) {
      const selectedImage = mainImages[selectedMainImageIndex];
      if (selectedImage) {
         if (selectedImage.isExisting) {
            productDataWithoutJunctions.main_image_url = selectedImage.url;
         } else if (
            newImageUrls[selectedMainImageIndex - existingImages.length]
         ) {
            productDataWithoutJunctions.main_image_url =
               newImageUrls[selectedMainImageIndex - existingImages.length];
         }
      }
   }

   const { data: updatedProduct, error: productError } = await sb
      .from("products")
      .update(productDataWithoutJunctions)
      .eq("id", productId)
      .select()
      .single();
   if (productError) throw productError;

   // Insert new images
   if (newImageUrls.length > 0) {
      const imagesToInsert = newImageUrls.map((url, i) => ({
         product_id: productId,
         url,
         position: existingImages.length + i,
         is_primary: existingImages.length + i === selectedMainImageIndex,
      }));
      await sb.from("product_images").insert(imagesToInsert);
   }

   for (const variation of variationsData) {
      const {
         imageFiles = [],
         existingImages = [],
         ...variationDetails
      } = variation;
      const { data: newVar, error: varErr } = await sb
         .from("product_variations")
         .insert({ ...variationDetails, product_id: productId })
         .select("id")
         .single();
      if (varErr) throw varErr;
      if (existingImages.length > 0) {
         const existingImgs = existingImages.map((img, i) => ({
            product_id: productId,
            product_variation_id: newVar.id,
            url: img.url,
            position: i,
            is_primary: false,
         }));
         await sb.from("product_images").insert(existingImgs);
      }
      if (imageFiles.length > 0) {
         const varUrls = await Promise.all(
            imageFiles.map((f) => uploadFile(f, "product-images"))
         );
         const varImgs = varUrls.map((url, i) => ({
            product_id: productId,
            product_variation_id: newVar.id,
            url,
            position: existingImages.length + i,
         }));
         await sb.from("product_images").insert(varImgs);
      }
   }
   return updatedProduct;
}

export async function fetchProductForEdit(id: string) {
   const { data: product, error } = await sb
      .from("products")
      .select("*")
      .eq("id", id)
      .single();
   if (error) throw error;

   // Fetch categories and subcategories
   const { data: productCategories } = await sb
      .from("product_categories")
      .select("category_id")
      .eq("product_id", id);
   const { data: productSubcategories } = await sb
      .from("product_subcategories")
      .select("subcategory_id")
      .eq("product_id", id);

   const { data: images } = await sb
      .from("product_images")
      .select("*")
      .eq("product_id", id)
      .order("position");
   const { data: variations } = await sb
      .from("product_variations")
      .select("*")
      .eq("product_id", id);

   const mainImages = (images || []).filter(
      (img: { product_variation_id: any }) => !img.product_variation_id
   );
   const variationsWithImages = (variations || []).map((v: { id: any }) => ({
      ...v,
      images: (images || []).filter(
         (img: { product_variation_id: any }) =>
            img.product_variation_id === v.id
      ),
   }));

   return {
      product: {
         ...product,
         categories: (productCategories || []).map((pc: any) => pc.category_id),
         subcategories: (productSubcategories || []).map(
            (ps: any) => ps.subcategory_id
         ),
      },
      mainImages,
      variations: variationsWithImages,
   };
}

export async function fetchProductsPage({
   filters = {},
   pagination = { page: 1, limit: 10 },
   sort = { column: "created_at", direction: "desc" },
}: ProductQueryOptions) {
   const from = (pagination.page - 1) * pagination.limit;
   const to = from + pagination.limit - 1;

   // If filtering by category, we need to use a different approach
   if (filters.category && filters.category !== "all") {
      // First get product IDs that belong to the selected category
      const { data: productIds, error: idsError } = await sb
         .from("product_categories")
         .select("product_id")
         .eq("category_id", filters.category);

      if (idsError) throw idsError;

      const ids = productIds?.map((pc: any) => pc.product_id) || [];

      if (ids.length === 0) {
         return { data: [], count: 0 };
      }

      // Now query products with these IDs
      let query = sb
         .from("products")
         .select(
            `
             *,
             category:categories(id, name),
             categories:product_categories(category:categories(id, name)),
             subcategories:product_subcategories(subcategory:subcategories(id, name))
          `,
            { count: "exact" }
         )
         .in("id", ids);

      // Apply other filters
      if (filters.search && filters.search.trim()) {
         const term = `%${filters.search.trim()}%`;
         query = query.or(
            `name.ilike.${term},brand.ilike.${term},sku.ilike.${term}`
         );
      }

      if (filters.status && filters.status !== "all") {
         query = query.eq("status", filters.status);
      }

      // Apply sorting and pagination
      const { data, error, count } = await query
         .order(sort.column, { ascending: sort.direction === "asc" })
         .range(from, to);

      if (error) throw error;

      // Transform the data to flatten the nested relations
      const transformedData = (data || []).map((product: any) => ({
         ...product,
         categories:
            product.categories?.map((pc: any) => pc.category).filter(Boolean) ||
            [],
         subcategories:
            product.subcategories
               ?.map((ps: any) => ps.subcategory)
               .filter(Boolean) || [],
      }));

      return { data: transformedData as Product[], count: count ?? 0 };
   }

   // Standard query without category filtering
   let query = sb.from("products").select(
      `
          *,
          category:categories(id, name),
          categories:product_categories(category:categories(id, name)),
          subcategories:product_subcategories(subcategory:subcategories(id, name))
       `,
      { count: "exact" }
   );

   // Apply filters
   if (filters.search && filters.search.trim()) {
      const term = `%${filters.search.trim()}%`;
      query = query.or(
         `name.ilike.${term},brand.ilike.${term},sku.ilike.${term}`
      );
   }

   if (filters.status && filters.status !== "all") {
      query = query.eq("status", filters.status);
   }

   // Apply sorting and pagination
   const { data, error, count } = await query
      .order(sort.column, { ascending: sort.direction === "asc" })
      .range(from, to);

   if (error) throw error;

   // Transform the data to flatten the nested relations
   const transformedData = (data || []).map((product: any) => ({
      ...product,
      categories:
         product.categories?.map((pc: any) => pc.category).filter(Boolean) ||
         [],
      subcategories:
         product.subcategories
            ?.map((ps: any) => ps.subcategory)
            .filter(Boolean) || [],
   }));

   return { data: transformedData as Product[], count: count ?? 0 };
}

export async function fetchAllProductsForExport({
   filters = {},
   sort = { column: "created_at", direction: "desc" },
}: Omit<ProductQueryOptions, "pagination">) {
   // If filtering by category, we need to use a different approach
   if (filters.category && filters.category !== "all") {
      // First get product IDs that belong to the selected category
      const { data: productIds, error: idsError } = await sb
         .from("product_categories")
         .select("product_id")
         .eq("category_id", filters.category);

      if (idsError) throw idsError;

      const ids = productIds?.map((pc: any) => pc.product_id) || [];

      if (ids.length === 0) {
         return [];
      }

      // Now query products with these IDs
      let query = sb
         .from("products")
         .select(
            `
             *,
             category:categories(id, name),
             categories:product_categories(category:categories(id, name)),
             subcategories:product_subcategories(subcategory:subcategories(id, name))
          `
         )
         .in("id", ids);

      // Apply other filters
      if (filters.search && filters.search.trim()) {
         const term = `%${filters.search.trim()}%`;
         query = query.or(
            `name.ilike.${term},brand.ilike.${term},sku.ilike.${term}`
         );
      }

      if (filters.status && filters.status !== "all") {
         query = query.eq("status", filters.status);
      }

      const { data, error } = await query
         .order(sort.column, { ascending: sort.direction === "asc" })
         .limit(5000);

      if (error) throw error;

      // Transform the data to flatten the nested relations
      const transformedData = (data || []).map((product: any) => ({
         ...product,
         categories:
            product.categories?.map((pc: any) => pc.category).filter(Boolean) ||
            [],
         subcategories:
            product.subcategories
               ?.map((ps: any) => ps.subcategory)
               .filter(Boolean) || [],
      }));

      return transformedData as Product[];
   }

   // Standard query without category filtering
   let query = sb.from("products").select(`
          *,
          category:categories(id, name),
          categories:product_categories(category:categories(id, name)),
          subcategories:product_subcategories(subcategory:subcategories(id, name))
       `);

   // Apply filters
   if (filters.search && filters.search.trim()) {
      const term = `%${filters.search.trim()}%`;
      query = query.or(
         `name.ilike.${term},brand.ilike.${term},sku.ilike.${term}`
      );
   }

   if (filters.status && filters.status !== "all") {
      query = query.eq("status", filters.status);
   }

   const { data, error } = await query
      .order(sort.column, { ascending: sort.direction === "asc" })
      .limit(5000);

   if (error) throw error;

   // Transform the data to flatten the nested relations
   const transformedData = (data || []).map((product: any) => ({
      ...product,
      categories:
         product.categories?.map((pc: any) => pc.category).filter(Boolean) ||
         [],
      subcategories:
         product.subcategories
            ?.map((ps: any) => ps.subcategory)
            .filter(Boolean) || [],
   }));

   return transformedData as Product[];
}

export async function deleteProduct(id: string) {
   const { error } = await sb.from("products").delete().eq("id", id);
   if (error) throw error;
}

export async function updateProduct(id: string, updates: Partial<ProductBase>) {
   if (Object.keys(updates).length) {
      const { error } = await sb.from("products").update(updates).eq("id", id);
      if (error) throw error;
   }
}

export async function fetchCategories(): Promise<Category[]> {
   const { data, error } = await sb
      .from("categories")
      .select("id, name")
      .order("name");
   if (error) throw error;
   return data || [];
}

export async function fetchCategoriesWithSubcategories(): Promise<
   CategoryWithSubcategories[]
> {
   const { data, error } = await sb
      .from("categories")
      .select(`*, subcategories:subcategories(*)`)
      .order("name");
   if (error) throw error;
   return data || [];
}

export async function createBulkProducts(products: ProductBase[]) {
   const { data, error } = await sb.from("products").insert(products);
   if (error) throw error;
   return data;
}

export async function createProduct(
   product: ProductBase,
   variations?: ProductVariation[]
) {
   const { data, error } = await sb
      .from("products")
      .insert(product)
      .select()
      .single();
   if (error) throw error;

   if (variations && variations.length > 0) {
      const variationsWithProductId = variations.map((v) => ({
         ...v,
         product_id: data.id,
      }));
      const { error: variationsError } = await sb
         .from("product_variations")
         .insert(variationsWithProductId);
      if (variationsError) throw variationsError;
   }

   return data;
}

export interface ProductReview {
   id: string;
   rating: number;
   title: string | null;
   content: string | null;
   image_url: string | null;
   created_at: string;
   author: {
      full_name: string | null;
   } | null;
}

export async function fetchProductWithReviews(productId: string) {
   const { data: product, error: productError } = await sb
      .from("products")
      .select("id, name")
      .eq("id", productId)
      .single();

   if (productError) throw productError;

   const { data: reviews, error: reviewsError } = await sb
      .from("reviews")
      .select(
         "id, rating, title, content, image_url, created_at, author:profiles!user_id(full_name)"
      )
      .eq("product_id", productId)
      .order("created_at", { ascending: false });

   if (reviewsError) throw reviewsError;

   return { product, reviews: reviews as ProductReview[] };
}

export async function deleteReview(reviewId: string) {
   // First, fetch the review to get the image_url
   const { data: review, error: fetchError } = await sb
      .from("reviews")
      .select("image_url")
      .eq("id", reviewId)
      .single();

   if (fetchError) throw fetchError;

   // If there's an image, delete it from storage
   if (review?.image_url) {
      try {
         // Extract the file path from the URL
         const urlParts = review.image_url.split("/");
         const fileName = urlParts[urlParts.length - 1];

         if (fileName) {
            const { error: storageError } = await sb.storage
               .from("reviews-images")
               .remove([fileName]);

            if (storageError) {
               console.warn(
                  "Failed to delete review image from storage:",
                  storageError
               );
               // Don't throw here - we still want to delete the review even if image deletion fails
            }
         }
      } catch (storageErr) {
         console.warn("Error deleting review image:", storageErr);
         // Continue with review deletion
      }
   }

   // Delete the review
   const { error } = await sb.from("reviews").delete().eq("id", reviewId);

   if (error) throw error;
}

// Lightweight product fetch for selectors to avoid heavy joins and timeouts
export async function fetchProductsLight(limit = 500) {
   const { data, error } = await sb
      .from("products")
      .select("id, name, price, main_image_url")
      .order("created_at", { ascending: false })
      .limit(limit);

   if (error) throw error;
   return (data || []) as Product[];
}


================
File: src/integrations/supabase/store.ts
================
import { supabase } from "@/integrations/supabase/client";
import { cache } from "react";

const sb = supabase as any;

// --- TYPES FOR PRODUCT LISTING PAGE ---
export interface StoreProduct {
  id: string;
  name: string;
  price: number;
  main_image_url: string | null;
  average_rating: number | null;
  review_count: number | null;
  brand: string | null;
  category: { id: string; name: string } | null;
}
export interface StoreCategory {
  id: string;
  name: string;
  products_count: number;
}
export interface StoreSubcategory {
   id: string;
   name: string;
   category_id: string;
   products_count: number;
}
export interface StoreFilters {
  categories?: string[];
  subcategories?: string[];
  rating?: number;
}
export interface StoreQueryOptions {
  search?: string;
  filters?: StoreFilters;
  sort?: { column: string; direction: "asc" | "desc" };
  pagination: { page: number; limit: number };
}

// --- TYPES FOR PRODUCT DETAIL PAGE ---
export interface ProductDetail extends StoreProduct {
  description: string | null;
  short_description: string | null;
  compare_at_price: number | null;
  stock?: number | null | undefined;
}
export interface ProductVariationDetail {
  id: string;
  name: string | null;
  price: number | null;
  stock: number;
  attributes: Record<string, string>;
}
export interface ProductImageDetail {
  id: string;
  url: string;
  product_variation_id: string | null;
}
export interface ProductReview {
  id: string;
  rating: number;
  title: string | null;
  content: string | null;
  image_url: string | null;
  created_at: string;
  author: { full_name: string | null } | null;
}
export interface ProductPageData {
  product: ProductDetail;
  variations: ProductVariationDetail[];
  images: ProductImageDetail[];
  reviews: ProductReview[];
  similarProducts: StoreProduct[];
}
export interface ReviewBase {
  product_id: string;
  user_id: string;
  rating: number;
  title?: string;
  content?: string;
  image_url?: string;
}
export interface StoreCategorySimple {
  id: string;
  name: string;
}

// --- DATA FETCHING FUNCTIONS ---

const applyStoreFilters = (
  query: any,
  { search = "", filters = {} }: Pick<StoreQueryOptions, "search" | "filters">
) => {
  let q = query.in("status", ["active", "out_of_stock"]);

  // Apply category and subcategory filters using junction tables
  if (filters.categories && filters.categories.length > 0) {
    // For category filtering, we need to use a different approach since we're using junction tables
    // This will be handled in the main query function
  }
  if (filters.subcategories && filters.subcategories.length > 0) {
    // For subcategory filtering, we need to use a different approach since we're using junction tables
    // This will be handled in the main query function
  }
  if (filters.rating) {
    q = q.gte("average_rating", filters.rating);
  }

  // Apply search filter - use FTS if available, fallback to ILIKE
  if (search.trim()) {
    // Try FTS first, but since we need to combine with other filters,
    // we'll use a more targeted approach
    q = q.or(`name.ilike.%${search.trim()}%,brand.ilike.%${search.trim()}%,short_description.ilike.%${search.trim()}%`);
  }

  return q;
};

export const fetchStoreProducts = cache(async (
  options: StoreQueryOptions
): Promise<{ data: StoreProduct[]; count: number }> => {
  // If filtering by categories or subcategories, we need to use a different approach
  if ((options.filters?.categories && options.filters.categories.length > 0) ||
      (options.filters?.subcategories && options.filters.subcategories.length > 0)) {

    // First get product IDs that match the category/subcategory filters
    let productIds: string[] = [];

    if (options.filters.categories && options.filters.categories.length > 0) {
      const { data: catProductIds, error: catError } = await sb
        .from("product_categories")
        .select("product_id")
        .in("category_id", options.filters.categories);

      if (catError) throw catError;
      productIds = (catProductIds || []).map((pc: any) => pc.product_id);
    }

    if (options.filters.subcategories && options.filters.subcategories.length > 0) {
      const { data: subProductIds, error: subError } = await sb
        .from("product_subcategories")
        .select("product_id")
        .in("subcategory_id", options.filters.subcategories);

      if (subError) throw subError;
      const subIds = (subProductIds || []).map((ps: any) => ps.product_id);

      // If we have both category and subcategory filters, intersect the results
      if (productIds.length > 0) {
        productIds = productIds.filter(id => subIds.includes(id));
      } else {
        productIds = subIds;
      }
    }

    if (productIds.length === 0) {
      return { data: [], count: 0 };
    }

    // Now query products with these IDs and apply other filters
    let query = sb
      .from("products")
      .select("id", { count: "exact", head: true })
      .in("id", productIds)
      .in("status", ["active", "out_of_stock"]);

    // Apply other filters
    if (options.filters.rating) {
      query = query.gte("average_rating", options.filters.rating);
    }
    if (options.search && options.search.trim()) {
      const searchTerm = options.search.trim();
      query = query.or(`name.ilike.%${searchTerm}%,brand.ilike.%${searchTerm}%,short_description.ilike.%${searchTerm}%`);
    }

    const { count, error: countError } = await query;
    if (countError) throw countError;

    const from = (options.pagination.page - 1) * options.pagination.limit;
    const to = from + options.pagination.limit - 1;

    // Now get the actual data
    let dataQuery = sb
      .from("products")
      .select(
        "id, name, price, short_description, main_image_url, average_rating, review_count, brand, category:categories(id, name)"
      )
      .in("id", productIds)
      .in("status", ["active", "out_of_stock"]);

    // Apply other filters again
    if (options.filters.rating) {
      dataQuery = dataQuery.gte("average_rating", options.filters.rating);
    }
    if (options.search && options.search.trim()) {
      const searchTerm = options.search.trim();
      dataQuery = dataQuery.or(`name.ilike.%${searchTerm}%,brand.ilike.%${searchTerm}%,short_description.ilike.%${searchTerm}%`);
    }

    const { data, error } = await dataQuery
      .order(options.sort?.column || "created_at", {
        ascending: options.sort?.direction === "asc",
      })
      .range(from, to);

    if (error) throw error;
    return { data: data as StoreProduct[], count: count ?? 0 };
  }

  // Standard query without category/subcategory filtering
  let countQuery = sb
    .from("products")
    .select("id", { count: "exact", head: true });
  // Apply all filters
  countQuery = applyStoreFilters(countQuery, options);

  const { count, error: countError } = await countQuery;
  if (countError) throw countError;

  const from = (options.pagination.page - 1) * options.pagination.limit;
  const to = from + options.pagination.limit - 1;

  // Start the data query chain with a select
  let dataQuery = sb
    .from("products")
    .select(
      "id, name, price, short_description, main_image_url, average_rating, review_count, brand, category:categories(id, name)"
    );
  // Apply all filters again
  dataQuery = applyStoreFilters(dataQuery, options);

  const { data, error } = await dataQuery
    .order(options.sort?.column || "created_at", {
      ascending: options.sort?.direction === "asc",
    })
    .range(from, to);

  if (error) throw error;
  return { data: data as StoreProduct[], count: count ?? 0 };
});

export const fetchStoreFilterData = cache(async (): Promise<{ categories: StoreCategory[] }> => {
   const { data, error } = await sb.rpc("get_categories_with_product_count");
   if (error) throw error;
   return { categories: data as StoreCategory[] };
});

export const fetchAllCategoriesWithSubcategories = cache(async (): Promise<{ categories: StoreCategory[], subcategories: StoreSubcategory[] }> => {
   try {
      const [categoriesRes, subcategoriesRes] = await Promise.all([
         sb.rpc("get_categories_with_product_count"),
         sb.from("subcategories").select("id, name, category_id").order("name")
      ]);

      if (categoriesRes.error) throw categoriesRes.error;
      if (subcategoriesRes.error) throw subcategoriesRes.error;

      // Add products_count to subcategories (we'll calculate this client-side or set to 0 for now)
      const subcategoriesWithCount = (subcategoriesRes.data || []).map((sub: any) => ({
         ...sub,
         products_count: 0 // We'll calculate this properly later if needed
      }));

      return {
         categories: categoriesRes.data as StoreCategory[],
         subcategories: subcategoriesWithCount as StoreSubcategory[]
      };
   } catch (error) {
      console.error("Error in fetchAllCategoriesWithSubcategories:", error);
      throw error;
   }
});
export async function fetchStoreSubcategories(categoryIds: string[] = []) {
  const { data, error } = await sb.rpc("get_subcategories_with_product_count", {
    parent_category_ids: categoryIds,
  });
  if (error) throw error;
  return { subcategories: data as StoreSubcategory[] };
}
export const fetchStoreProductById = cache(async (id: string): Promise<ProductPageData | null> => {
  const { data: product, error } = await sb
    .from("products")
    .select(
      `id, name, description, short_description, stock, price, compare_at_price, main_image_url, average_rating, review_count, brand, category:categories(id, name), categories:product_categories(category:categories(id, name)), subcategories:product_subcategories(subcategory:subcategories(id, name))`
    )
    .eq("id", id)
    .in("status", ["active", "out_of_stock"])
    .maybeSingle();
  if (error || !product) {
    return null;
  }

  // Transform the product data to flatten nested relations
  const transformedProduct = {
    ...product,
    categories: product.categories?.map((pc: any) => pc.category).filter(Boolean) || [],
    subcategories: product.subcategories?.map((ps: any) => ps.subcategory).filter(Boolean) || [],
  };

  const [variationsRes, imagesRes, reviewsRes] = await Promise.all([
    sb
      .from("product_variations")
      .select("id, name, price, stock, attributes")
      .eq("product_id", id),
    sb
      .from("product_images")
      .select("id, url, product_variation_id")
      .eq("product_id", id),
    sb
      .from("reviews")
      .select(
        "id, rating, title, content, image_url, created_at, author:profiles!user_id(full_name)"
      )
      .eq("product_id", id),
  ]);
  if (variationsRes.error) throw variationsRes.error;
  if (imagesRes.error) throw imagesRes.error;
  if (reviewsRes.error) throw reviewsRes.error;

  // Get similar products based on shared categories
  let similarProducts: StoreProduct[] = [];
  const productCategories = transformedProduct.categories;
  if (productCategories && productCategories.length > 0) {
    // Get product IDs that share categories with this product
    const categoryIds = productCategories.map((cat: any) => cat.id);
    const { data: similarProductIds, error: similarError } = await sb
      .from("product_categories")
      .select("product_id")
      .in("category_id", categoryIds)
      .neq("product_id", id);

    if (!similarError && similarProductIds && similarProductIds.length > 0) {
      const uniqueProductIds = [...new Set(similarProductIds.map((sp: any) => sp.product_id))];

      const { data: similarData } = await sb
        .from("products")
        .select(
          "id, name, price, main_image_url, short_description, average_rating, category:categories(id, name)"
        )
        .in("id", uniqueProductIds)
        .in("status", ["active", "out_of_stock"])
        .limit(6);

      similarProducts = similarData || [];
    }
  }

  return {
    product: transformedProduct as ProductDetail,
    variations: (variationsRes.data || []) as ProductVariationDetail[],
    images: (imagesRes.data || []) as ProductImageDetail[],
    reviews: (reviewsRes.data || []) as ProductReview[],
    similarProducts,
  };
});
export async function createStoreReview(
  reviewData: ReviewBase,
  imageFile?: File
): Promise<ProductReview> {
  const {
    data: { session },
  } = await supabase.auth.getSession();
  if (!session) {
    throw new Error("You must be logged in to leave a review.");
  }
  if (reviewData.user_id !== session.user.id) {
    throw new Error("User ID mismatch.");
  }

  let imageUrl = reviewData.image_url || null;

  // Upload image if provided
  if (imageFile) {
    const fileExt = imageFile.name.split(".").pop();
    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
    const { error: uploadError } = await sb.storage
      .from("reviews-images")
      .upload(fileName, imageFile);
    if (uploadError) throw uploadError;

    const { data: urlData } = sb.storage
      .from("reviews-images")
      .getPublicUrl(fileName);
    imageUrl = urlData.publicUrl;
  }

  const reviewToInsert = {
    ...reviewData,
    image_url: imageUrl,
  };

  const { data, error } = await sb
    .from("reviews")
    .insert(reviewToInsert)
    .select("*, author:profiles!user_id(full_name)")
    .single();
  if (error) {
    if (error.code === "23505") {
      throw new Error("You have already submitted a review for this product.");
    }
    throw error;
  }
  return data as ProductReview;
}
export const fetchStoreCategories = cache(async (): Promise<StoreCategorySimple[]> => {
  const { data, error } = await sb
    .from("categories")
    .select("id, name")
    .limit(8);
  if (error) throw error;
  return data || [];
});
export const fetchProductsUnder15k = cache(async (
  categoryId?: string
): Promise<StoreProduct[]> => {
  let query = sb
    .from("products")
    .select(
      "id, name, price, main_image_url, short_description, average_rating, brand, category:categories(id, name)"
    )
    .in("status", ["active", "out_of_stock"])
    .lte("price", 15000)
    .order("description", { ascending: false })
    .limit(15);
  if (categoryId && categoryId !== "all") {
    query = query.eq("category_id", categoryId);
  }
  const { data, error } = await query;
  if (error) throw error;
  return data as StoreProduct[];
});
// export async function fetchLandingPageProducts({ categoryId, featured, limit }: { categoryId?: string, featured?: boolean, limit: number }): Promise<StoreProduct[]> {
//     let query = sb.from('products').select('id, name, price, short_description, main_image_url, average_rating, brand, category:categories(id, name)').in('status', ['active', 'out_of_stock']).order('created_at', { ascending: false }).limit(limit);
//     if (featured !== undefined) { query = query.eq('featured', featured); }
//     if (categoryId && categoryId !== 'all') { query = query.eq('category_id', categoryId); }
//     const { data, error } = await query;
//     if (error) throw error;
//     return data as StoreProduct[];
// }

export const fetchLandingPageProducts = cache(async ({
  categoryId,
  featured,
  limit,
  offset = 0,
  sortBy,
}: {
  categoryId?: string;
  featured?: boolean;
  limit: number;
  offset?: number;
  sortBy?: string;
}): Promise<StoreProduct[]> => {
  let query = sb
    .from("products")
    .select(
      "id, name, price, short_description, main_image_url, average_rating, brand, category:categories(id, name)"
    )
    .in("status", ["active", "out_of_stock"]);

  if (featured !== undefined) {
    query = query.eq("featured", featured);
  }
  if (categoryId && categoryId !== "all") {
    query = query.eq("category_id", categoryId);
  }

  // Apply ordering and pagination
  if (sortBy) {
    // Custom sorting by specified column, with secondary sort by id for stability
    query = query.order(sortBy, { ascending: true }).order("id", { ascending: true }).range(offset, offset + limit - 1);
  } else {
    // Default to latest ordering
    query = query.order("created_at", { ascending: false }).order("id", { ascending: true }).range(offset, offset + limit - 1);
  }

  const { data, error } = await query;
  if (error) throw error;
  return data as StoreProduct[];
});

export interface SearchResult {
  id: string;
  name: string;
  main_image_url: string | null;
  short_description: string | null;
}
export const searchProductsByName = cache(async (
  query: string
): Promise<SearchResult[]> => {
  if (!query.trim() || query.trim().length < 2) {
    return [];
  }

  const searchTerm = query.trim();

  // Use the new Full-Text Search RPC function for better relevance and ranking
  const { data, error } = await sb.rpc('search_products_fts', {
    search_term: searchTerm
  });

  if (error) {
    console.error("Error searching products with FTS:", error);
    // Fallback to basic search if FTS is not available
    const { data: fallbackData, error: fallbackError } = await sb
      .from("products")
      .select("id, name, main_image_url, short_description")
      .in("status", ["active", "out_of_stock"])
      .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,short_description.ilike.%${searchTerm}%,tags.cs.{${searchTerm}}`)
      .limit(5);

    if (fallbackError) {
      console.error("Error with fallback search:", fallbackError);
      return [];
    }
    return fallbackData as SearchResult[];
  }

  return data as SearchResult[];
});

export const fetchAllProductIds = cache(async (): Promise<string[]> => {
  const { data, error } = await sb
    .from("products")
    .select("id")
    .in("status", ["active", "out_of_stock"]);

  if (error) throw error;
  return (data || []).map((product: { id: string }) => product.id);
});
